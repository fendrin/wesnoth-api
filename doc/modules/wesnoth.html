<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Moonscript/Lua API Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>wesnoth-love</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#api_actions_Functions">api.actions Functions</a></li>
<li><a href="#api_controller_Functions">api.controller Functions</a></li>
<li><a href="#api_files_Functions">api.files Functions</a></li>
<li><a href="#api_gui_Functions">api.gui Functions</a></li>
<li><a href="#api_interface_Functions">api.interface Functions</a></li>
<li><a href="#api_map_Functions">api.map Functions</a></li>
<li><a href="#api_misc_Functions">api.misc Functions</a></li>
<li><a href="#api_pathfinder_Functions">api.pathfinder Functions</a></li>
<li><a href="#api_side_ai_Functions">api.side_ai Functions</a></li>
<li><a href="#api_sides_Functions">api.sides Functions</a></li>
<li><a href="#api_sound_Functions">api.sound Functions</a></li>
<li><a href="#api_time_Functions">api.time Functions</a></li>
<li><a href="#api_units_Functions">api.units Functions</a></li>
<li><a href="#api_variables_Functions">api.variables Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>wesnoth</strong></li>
  <li><a href="../modules/helper.html">helper</a></li>
  <li><a href="../modules/items.html">items</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/README.md.html">README</a></li>
  <li><a href="../topics/LICENSE.html">LICENSE</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>wesnoth</code></h1>
<p>

</p>
<p>

</p>


<h2><a href="#api_actions_Functions">api.actions Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#add_event_handler">add_event_handler (cfg)</a></td>
	<td class="summary">Registers a new event handler.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#remove_event_handler">remove_event_handler (id)</a></td>
	<td class="summary">Removes an event handler.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#eval_conditional">eval_conditional (conditional_table)</a></td>
	<td class="summary">Returns true if the conditional described by the WSL table passes.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#tovconfig">tovconfig ()</a></td>
	<td class="summary">Converts a WSL table into a proxy object which performs variable substitution on the fly.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.set_wsl_action_metatable">helper.set_wsl_action_metatable ()</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.wsl_error">helper.wsl_error ()</a></td>
	<td class="summary">Interrupts the @current execution and displays a chat message that looks like a WSL error.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.literal">helper.literal ()</a></td>
	<td class="summary">Returns the __literal field of its argument if it is a userdata, the argument itself otherwise.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.parsed">helper.parsed ()</a></td>
	<td class="summary">Returns the __parsed field of its argument if it is a userdata, the argument itself otherwise.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.shallow_literal">helper.shallow_literal ()</a></td>
	<td class="summary">Returns the _<em>shallow</em>literal field of its argument if it is a userdata, the argument itself otherwise.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.shallow_parsed">helper.shallow_parsed ()</a></td>
	<td class="summary">Returns the _<em>shallow</em>parsed field of its argument if it is a userdata, the argument itself otherwise.</td>
	</tr>
</table>
<h2><a href="#api_controller_Functions">api.controller Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#load_scenario">load_scenario (id)</a></td>
	<td class="summary">Setups a scenario's assets to be ready to start</td>
	</tr>
	<tr>
	<td class="name" ><a href="#load_campaign">load_campaign (id)</a></td>
	<td class="summary">Reloads the data tree with the specified campaign's define set</td>
	</tr>
</table>
<h2><a href="#api_files_Functions">api.files Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#dofile">dofile (path)</a></td>
	<td class="summary">Replaces basic.dofile for loading files.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#require">require (path)</a></td>
	<td class="summary">Loads the given filename (relative to the content directory) and executes it in a protected environment.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#have_file">have_file ()</a></td>
	<td class="summary">Tests if a file exists.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#read_file">read_file ()</a></td>
	<td class="summary">Reads a file into a string.</td>
	</tr>
</table>
<h2><a href="#api_gui_Functions">api.gui Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.show_message_dialog">wesmere.show_message_dialog (attributes, options, text_input_attributes)</a></td>
	<td class="summary">Shows a message dialog, of the type used by the message ActionWSL function.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.show_popup_dialog">wesmere.show_popup_dialog (title, message[, image])</a></td>
	<td class="summary">Shows a simple popup dialog in the centre of the screen.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.show_dialog">wesmere.show_dialog ()</a></td>
	<td class="summary">Displays a dialog box described by a WSL table and returns:
 The dialog box is equivalent to the resolution section of a GUI window as described in GUIToolkitWSL and must therefore contain at least the following children: [tooltip], [helptip], and [grid].</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_value">wesmere.set_dialog_value ()</a></td>
	<td class="summary">Sets the value of a widget on the current dialog.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_dialog_value">wesmere.get_dialog_value ()</a></td>
	<td class="summary">Gets the value of a widget on the current dialog.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_active">wesmere.set_dialog_active (active)</a></td>
	<td class="summary">Enables or disables a widget.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_callback">wesmere.set_dialog_callback (callback_function)</a></td>
	<td class="summary">Sets the first argument as a callback function for the widget obtained by following the path of the other arguments
 This function will be called whenever the user modifies something about the widget, so that the dialog can react to it.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_markup">wesmere.set_dialog_markup (allowed)</a></td>
	<td class="summary">Sets the flag associated to a widget to enable or disable Pango markup.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_focus">wesmere.set_dialog_focus (focused)</a></td>
	<td class="summary">Switches the keyboard focus to the widget found following the given path.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_visible">wesmere.set_dialog_visible (visible)</a></td>
	<td class="summary">Sets a widget's visibility status.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_dialog_value">wesmere.set_dialog_value (index, content)</a></td>
	<td class="summary">Sets the WSL passed as the second argument as the canvas content (index given by the first argument) of the widget obtained by following the path of the other arguments (see #wesmere.set<em>dialog</em>value).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.add_dialog_tree_node">wesmere.add_dialog_tree_node (type, index)</a></td>
	<td class="summary">Adds a childnode to a treeview widget or a treeview node.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.remove_dialog_item">wesmere.remove_dialog_item (index, count)</a></td>
	<td class="summary">Removes an item from a listbox, a multipage or a treeview.</td>
	</tr>
</table>
<h2><a href="#api_interface_Functions">api.interface Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.message">wesmere.message ([speaker="<Lua>"], message)</a></td>
	<td class="summary">Displays a string in the chat window and dumps it to the lua/info log domain (--log-info=scripting/lua on the command-line).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.clear_messages">wesmere.clear_messages ()</a></td>
	<td class="summary">Removes all messages from the chat window.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.textdomain">wesmere.textdomain ()</a></td>
	<td class="summary">Creates a function proxy for lazily translating strings from the given domain.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.delay">wesmere.delay (milliseconds)</a></td>
	<td class="summary">Delays the engine like the [delay] tag.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.float_label">wesmere.float_label (x, y, text)</a></td>
	<td class="summary">Pops some text above a map tile.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.select_hex">wesmere.select_hex (x, y[, show_movement=true[, fire_events=false]])</a></td>
	<td class="summary">Selects the given location in the game map as if the player would have clicked onto it.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.deselect_hex">wesmere.deselect_hex ()</a></td>
	<td class="summary">Reverses any select_hex call, leaving all locations unhighlighted.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.scroll_to_tile">wesmere.scroll_to_tile (x, y[, only_if_visible=false[, instant=false]])</a></td>
	<td class="summary">Scrolls the map to the given location.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.lock_view">wesmere.lock_view ([lock=true])</a></td>
	<td class="summary">Locks or unlocks gamemap view scrolling for human players.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.view_locked">wesmere.view_locked ()</a></td>
	<td class="summary">Returns a boolean indicating whether gamemap view scrolling is currently locked.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.play_sound">wesmere.play_sound (sound[, repeat_count=0])</a></td>
	<td class="summary">Plays the given sound file once, optionally repeating it one or more more times if an integer value is provided as a second argument (note that the sound is repeated the number of times specified in the second argument, i.e.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_music">wesmere.set_music (music_entry)</a></td>
	<td class="summary">Sets the given table as an entry into the music list.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.is_skipping_messages">wesmere.is_skipping_messages ()</a></td>
	<td class="summary">Returns true if messages are currently being skipped, for example because the player has chosen to skip replay, or has pressed escape to dismiss a message.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.skip_messages">wesmere.skip_messages ([skip=true])</a></td>
	<td class="summary">Sets the skip messages flag.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_displayed_unit">wesmere.get_displayed_unit ()</a></td>
	<td class="summary">Returns a proxy to the unit currently displayed in the side pane of the user interface, if any.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.theme_items">wesmere.theme_items</a></td>
	<td class="summary">This field is not a function but an associative table.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.get_user_choice">helper.get_user_choice (message_table, options)</a></td>
	<td class="summary">Displays a WSL message box querying a choice from the user.</td>
	</tr>
</table>
<h2><a href="#api_map_Functions">api.map Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.get_map_size">wesmere.get_map_size (state)</a></td>
	<td class="summary">Returns the width, the height, and the border size of the map.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#get_terrain">get_terrain (x, y)</a></td>
	<td class="summary">Returns the terrain code for the given location.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#set_terrain">set_terrain (x, y, terrain_code[, layer="both"[, replace_if_failed=false]])</a></td>
	<td class="summary">Modifies the terrain at the given location.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_terrain_info">wesmere.get_terrain_info (terrain_code)</a></td>
	<td class="summary">Returns the terrain details for the given terrain code.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_selected_tile">wesmere.get_selected_tile ()</a></td>
	<td class="summary">Returns the two coordinates of the currently selected tile.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_villages">wesmere.get_villages ([filter])</a></td>
	<td class="summary">This function, when called without arguments, returns a table containing all the villages present on the map (as tables of two elements).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#match_location">match_location (x, y, filter)</a></td>
	<td class="summary">Returns true if the given location passes the filter.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_locations">wesmere.get_locations (See)</a></td>
	<td class="summary">Returns a table containing all the locations matching the given filter.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.add_tile_overlay">wesmere.add_tile_overlay (x, y, item_wsl)</a></td>
	<td class="summary">Places a tile overlay (either an image or a halo) at a given location.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.remove_tile_overlay">wesmere.remove_tile_overlay (x, y[, filename])</a></td>
	<td class="summary">Removes all the overlays at the given location.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#items.place_image">items.place_image (x, y, filename)</a></td>
	<td class="summary">Places an image at a given location and registers it as a WSL [item] would do, so that it can be restored after save/load.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#items.place_halo">items.place_halo (x, y, filename)</a></td>
	<td class="summary">Behaves the same as #items.place_image but for halos.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#items.remove">items.remove (x, y[, filename])</a></td>
	<td class="summary">Removes an overlay set by #items.place<em>image or #items.place</em>halo.</td>
	</tr>
</table>
<h2><a href="#api_misc_Functions">api.misc Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.game_config">wesmere.game_config</a></td>
	<td class="summary">Contrarily to the other values of the wesmere table, game_config is simply a proxy table.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_era">wesmere.get_era (id)</a></td>
	<td class="summary">A function which takes one argument, an era id, and returns the entire era table corresponding to that id.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.current">wesmere.current</a></td>
	<td class="summary">As with game_config, current is a proxy table.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.synchronize_choice">wesmere.synchronize_choice (func[, ai_func])</a></td>
	<td class="summary">(Version 1.13.2 and later only) wesmere.synchronize<em>choice([description], function, [ai</em>function], [for_side])
 Recovers a WSL table that was computed on one client only or was stored in a replay.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.synchronize_choices">wesmere.synchronize_choices ([description], func[, default_function[, for_sides]])</a></td>
	<td class="summary">(Version 1.13.2 and later only) Similar to the singular form above, this function takes a function parameter and evaluates it on the specified sides.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_image_size">wesmere.get_image_size (filename)</a></td>
	<td class="summary">Returns the width and height of an image.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.compare_versions">wesmere.compare_versions (version1, operator, version2)</a></td>
	<td class="summary">Takes two versions strings and an operator, returns whether the comparison yields true.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.have_file">wesmere.have_file (filename)</a></td>
	<td class="summary">Checks if the file (not necessarily a Lua file) or the directory passed as argument exists.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.debug">wesmere.debug (wsl_table)</a></td>
	<td class="summary">Takes a userdata with metatable wsl object or a wsl table and dumps its content into a pretty string.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_time_stamp">wesmere.get_time_stamp ()</a></td>
	<td class="summary">This function retrieves the current time stamp, that is the amount of milliseconds passed from when the SDL library was initialized.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.random">wesmere.random ([m[, n]])</a></td>
	<td class="summary">(Version 1.13.2 and later only) This function returns a random number generated by the synced random generator which is also used by [set_variable]rand= (and thus also by helper.rand).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.rand">helper.rand (spec)</a></td>
	<td class="summary">(A shortcut to set_variable's rand= since math.rand is an OOS magnet and therefore disabled.)
 create a random unit at (1, 1) on side=1 :</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.round">helper.round (number)</a></td>
	<td class="summary">Unlike other languages (Python, Perl, Javascript, ...), Lua does not include a round function.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#helper.shuffle">helper.shuffle (array[, random_function])</a></td>
	<td class="summary">This function randomly sorts in place the elements of the table passed as argument, following the Fisher-Yates algorithm.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#isArray">isArray (t)</a></td>
	<td class="summary">Check for a table not consisting of any records and thus being a pure array.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wrapInArray">wrapInArray (t)</a></td>
	<td class="summary">Checks if the given arguement is already</td>
	</tr>
</table>
<h2><a href="#api_pathfinder_Functions">api.pathfinder Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.find_path">wesmere.find_path (x1, y1, x2, y2, path_options)</a></td>
	<td class="summary">Returns the shortest path from one location to another.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#find_vacant_tile">find_vacant_tile (x, y[, unit])</a></td>
	<td class="summary">Returns the two coordinates of an empty tile the closest to the tile passed by coordinates.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#find_vacant_tile-todo1">find_vacant_tile-todo1</a></td>
	<td class="summary">do the real implementation.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.find_reach">wesmere.find_reach (unit[, path_options])</a></td>
	<td class="summary">Returns all the locations reachable by a unit.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#find_cost_map">find_cost_map (unit, another_unit, options, filter)</a></td>
	<td class="summary">Builds a cost map for one, multiple units or unit types.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#distance_between">distance_between (x1, x2, y1, y2)</a></td>
	<td class="summary">Returns the distance between two tiles given by their coordinates.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#adjacent_tiles">adjacent_tiles (x, y[, include_border])</a></td>
	<td class="summary">Returns an iterator on the (at most six) tiles around a given location that are on the map.</td>
	</tr>
</table>
<h2><a href="#api_side_ai_Functions">api.side_ai Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#switch_ai">switch_ai ()</a></td>
	<td class="summary">Tests if the given location is under shroud from the point of view of the given side.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#append_ai">append_ai ()</a></td>
	<td class="summary">(Version 1.13.7 and later only)
 Appends AI parameters (aspects, stages, goals) to the side's AI.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#add_ai_component">add_ai_component ()</a></td>
	<td class="summary">Adds a component to the side's AI.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#change_ai_component">change_ai_component ()</a></td>
	<td class="summary">Like add<em>ai</em>component, but replaces an existing component instead of adding a new one.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#delete_ai_component">delete_ai_component ()</a></td>
	<td class="summary">Like add<em>ai</em>component, but removes a component instead of adding one.</td>
	</tr>
</table>
<h2><a href="#api_sides_Functions">api.sides Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#sides">sides</a></td>
	<td class="summary">This is not a function but a table indexed by side numbers.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#set_village_owner">set_village_owner (x, y[, side=0[, fire_events=false]])</a></td>
	<td class="summary">Gives ownership of the village at the given location to the given side (or remove ownership if none).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#is_enemy">is_enemy (sideA, sideB)</a></td>
	<td class="summary">Returns true if sideA is enemy of sideB, false otherwise.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#get_sides">get_sides (filter)</a></td>
	<td class="summary">Returns a table array containing tables for these sides matching the passed StandardSideFilter.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#match_side">match_side (side, filter)</a></td>
	<td class="summary">Matches a side against a given StandardSideFilter.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#match_side-todo2">match_side-todo2</a></td>
	<td class="summary"> if (!side<em>string</em>.empty()) {</p>
<pre><code> if (!check_side_number(t,side_string_)) {
     return false;
 }
</code></pre>
<p> }</td>
	</tr>
	<tr>
	<td class="name" ><a href="#get_starting_location">get_starting_location ()</a></td>
	<td class="summary">Returns the starting location of the given side.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#get_village_owner">get_village_owner (x, y)</a></td>
	<td class="summary">Stub text</td>
	</tr>
	<tr>
	<td class="name" ><a href="#set_side_id">set_side_id (side)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" ><a href="#place_shroud">place_shroud ()</a></td>
	<td class="summary">Shrouds the specified hexes.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#remove_shroud">remove_shroud ()</a></td>
	<td class="summary">(Version 1.13.7 and later only)
 Unshrouds the specified hexes.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#is_fogged">is_fogged ()</a></td>
	<td class="summary">(Version 1.13.7 and later only)
 Tests if the given location is under fog from the point of view of the given side.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#is_shrouded">is_shrouded ()</a></td>
	<td class="summary">(Version 1.13.7 and later only)</td>
	</tr>
</table>
<h2><a href="#api_sound_Functions">api.sound Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#set_music">set_music (music_entry)</a></td>
	<td class="summary">Sets the given table as an entry into the music list.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list">music_list</a></td>
	<td class="summary">This is a table giving access to the current music playlist.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list.add">music_list.add (track_name[, immediate[, ms_before[, ms_after]]])</a></td>
	<td class="summary">Appends a track to the playlist.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list.remove">music_list.remove (...)</a></td>
	<td class="summary">Removes one or more tracks by their index.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list.clear">music_list.clear ()</a></td>
	<td class="summary">Clears the playlist.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list.next">music_list.next ()</a></td>
	<td class="summary">Stop playing the current track and move on to the next one.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#music_list.play">music_list.play (track_name)</a></td>
	<td class="summary">Start playing a track without appending it to the playlist.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#play_sound">play_sound (sound[, repeat_count])</a></td>
	<td class="summary">Plays the given sound file once,<br/>
 optionally repeating it one or more more times if an integer value
 is provided as a second argument
 (note that the sound is repeated the number of times specified in the second argument, i.e.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#sound_volume">sound_volume (new_volume)</a></td>
	<td class="summary">Sets the current sound volume.</td>
	</tr>
</table>
<h2><a href="#api_time_Functions">api.time Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.get_time_of_day">wesmere.get_time_of_day ([for_turn=turn_number[, Second]])</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.add_time_area">wesmere.add_time_area (cfg, string)</a></td>
	<td class="summary">Creates a new time area.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.remove_time_area">wesmere.remove_time_area (id)</a></td>
	<td class="summary">Removes a time area.</td>
	</tr>
</table>
<h2><a href="#api_units_Functions">api.units Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.get_unit">wesmere.get_unit (underlying_id)</a></td>
	<td class="summary">Returns the unit with the given underlying ID.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_unit">wesmere.get_unit (x, y)</a></td>
	<td class="summary">Returns the unit at the given location</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_units">wesmere.get_units (filter)</a></td>
	<td class="summary">Returns an array of all the units on the map matching the WSL filter passed as the first argument.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.match_unit">wesmere.match_unit (unit, filter[, other_unit])</a></td>
	<td class="summary">Returns true if the given unit matches the WSL filter passed as the second argument.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.erase_unit">wesmere.erase_unit (unit)</a></td>
	<td class="summary">Erases a unit from the map.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.erase_unit">wesmere.erase_unit (x, y)</a></td>
	<td class="summary">Erases a unit from the map.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_recall_units">wesmere.get_recall_units (filter)</a></td>
	<td class="summary">Returns an array of all the units on the recall lists matching the WSL filter passed as the first argument.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.put_recall_unit">wesmere.put_recall_unit (unit[, side])</a></td>
	<td class="summary">Places a unit on a recall list.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.create_unit">wesmere.create_unit (unit_info)</a></td>
	<td class="summary">Creates a private unit from a WSL table.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.copy_unit">wesmere.copy_unit ()</a></td>
	<td class="summary">Creates a private unit from another unit.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.extract_unit">wesmere.extract_unit ()</a></td>
	<td class="summary">Removes a unit from the map or from a recall list and makes it private.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.advance_unit">wesmere.advance_unit (unit, animate, fire_events)</a></td>
	<td class="summary">Advances the unit (and shows the advance unit dialog if needed) if the unit has enough xp.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.add_modification">wesmere.add_modification (It, type[, write_to_mods])</a></td>
	<td class="summary">Modifies a given unit.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_resistance">wesmere.unit_resistance (whether[, loc])</a></td>
	<td class="summary">Returns the resistance of a unit against an attack type.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_defense">wesmere.unit_defense ()</a></td>
	<td class="summary">Returns the defense of a unit on a particular terrain.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_movement_cost">wesmere.unit_movement_cost ()</a></td>
	<td class="summary">Returns the movement cost of a unit on a particular terrain.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_vision_cost">wesmere.unit_vision_cost ()</a></td>
	<td class="summary">Returns the vision cost of a unit on a particular terrain.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_jamming_cost">wesmere.unit_jamming_cost ()</a></td>
	<td class="summary">Returns the jamming cost of a unit on a particular terrain.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_ability">wesmere.unit_ability ()</a></td>
	<td class="summary">Returns true if the unit is currently under effect by an ability with this given TAG NAME.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.unit_types">wesmere.unit_types</a></td>
	<td class="summary">This is not a function but a table indexed by unit type ids.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.races">wesmere.races</a></td>
	<td class="summary">This is not a function but a table indexed by race ids.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_traits">wesmere.get_traits ()</a></td>
	<td class="summary">Returns a table with named fields (trait id strings) holding the wsl tables defining the traits.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.simulate_combat">wesmere.simulate_combat ()</a></td>
	<td class="summary">Computes the hitpoint distribution and status chance after a combat between two units.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.transform_unit">wesmere.transform_unit (unit, to_type)</a></td>
	<td class="summary">Changes the type of a unit and adjust attributes accordingly.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.put_unit">wesmere.put_unit (unit, x[, y])</a></td>
	<td class="summary">Places a unit on the map.</td>
	</tr>
</table>
<h2><a href="#api_variables_Functions">api.variables Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#wesmere.get_variable">wesmere.get_variable ()</a></td>
	<td class="summary">Loads a WSL variable with the given qualified name (argument 1) and converts it into a Lua object.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.set_variable">wesmere.set_variable ()</a></td>
	<td class="summary">Stores a Lua value (argument 2) to a WSL variable (argument 1).</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wesmere.get_all_vars">wesmere.get_all_vars ()</a></td>
	<td class="summary">Returns all the WSL variables currently set in form of a WSL table.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="api_actions_Functions"></a>api.actions Functions</h2>

    <dl class="function">
    <dt>
    <a name = "add_event_handler"></a>
    <strong>add_event_handler (cfg)</strong>
    </dt>
    <dd>
    Registers a new event handler.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cfg</span>
            <span class="types"><span class="type">tab</span></span>
         This takes a WSL table containing the same information normally used by the [event] table.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "remove_event_handler"></a>
    <strong>remove_event_handler (id)</strong>
    </dt>
    <dd>
    Removes an event handler.  This requires the event handler to have been assigned an id at creation time.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "eval_conditional"></a>
    <strong>eval_conditional (conditional_table)</strong>
    </dt>
    <dd>
    Returns true if the conditional described by the WSL table passes.  Note: WSL variables are substituted.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">conditional_table</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">result = wesnoth.eval_conditional
   have_unit:
       id: <span class="string">"hero"</span>
   variable:
       name: <span class="string">"counter"</span>
       numerical_equals: <span class="string">"old_counter"</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "tovconfig"></a>
    <strong>tovconfig ()</strong>
    </dt>
    <dd>
    Converts a WSL table into a proxy object which performs variable substitution on the fly.







</dd>
    <dt>
    <a name = "helper.set_wsl_action_metatable"></a>
    <strong>helper.set_wsl_action_metatable ()</strong>
    </dt>
    <dd>










</dd>
    <dt>
    <a name = "helper.wsl_error"></a>
    <strong>helper.wsl_error ()</strong>
    </dt>
    <dd>
    Interrupts the @current execution and displays a chat message that looks like a WSL error.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">names = cfg.name <span class="keyword">or</span> helper.wsl_error(<span class="string">"clear_variable() missing required name: key."</span>)
sl_error = (message) -&gt;
   <span class="global">error</span>(message)</pre>
    </ul>

</dd>
    <dt>
    <a name = "helper.literal"></a>
    <strong>helper.literal ()</strong>
    </dt>
    <dd>
    Returns the __literal field of its argument if it is a userdata, the argument itself otherwise.  This function is meant to be called when a WSL action handler can be called indifferently from WSL (hence receiving a userdata) or from Lua (hence possibly receiving a table).
 Note: when the argument is a plain table, the function returns it as is. In particular, modifying the fields of the returned table causes the original table to be modified too.






    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">function</span> wsl_actions.display_literal_value(cfg)
    cfg = helper.literal(cfg)
    wesnoth.message(<span class="global">tostring</span>(cfg.value))</pre>
    </ul>

</dd>
    <dt>
    <a name = "helper.parsed"></a>
    <strong>helper.parsed ()</strong>
    </dt>
    <dd>
    Returns the __parsed field of its argument if it is a userdata, the argument itself otherwise.  See also #helper.literal.







</dd>
    <dt>
    <a name = "helper.shallow_literal"></a>
    <strong>helper.shallow_literal ()</strong>
    </dt>
    <dd>
    Returns the _<em>shallow</em>literal field of its argument if it is a userdata, the argument itself otherwise.  See also #helper.literal.







</dd>
    <dt>
    <a name = "helper.shallow_parsed"></a>
    <strong>helper.shallow_parsed ()</strong>
    </dt>
    <dd>
    Returns the _<em>shallow</em>parsed field of its argument if it is a userdata, the argument itself otherwise.  See also #helper.literal.







</dd>
</dl>
    <h2 class="section-header "><a name="api_controller_Functions"></a>api.controller Functions</h2>

    <dl class="function">
    <dt>
    <a name = "load_scenario"></a>
    <strong>load_scenario (id)</strong>
    </dt>
    <dd>
    Setups a scenario's assets to be ready to start


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         of the scenario to load
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        if scenario was succesfully loaded.
    </ol>




</dd>
    <dt>
    <a name = "load_campaign"></a>
    <strong>load_campaign (id)</strong>
    </dt>
    <dd>
    Reloads the data tree with the specified campaign's define set


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>



        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="api_files_Functions"></a>api.files Functions</h2>

    <dl class="function">
    <dt>
    <a name = "dofile"></a>
    <strong>dofile (path)</strong>
    </dt>
    <dd>
    Replaces basic.dofile for loading files.
 Loads the given filename (relative to the content directory)
 and executes it in an unprotected environment
 (that is, exceptions propagate to the caller).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">path</span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Returns the values returned by the executed script.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesnoth.<span class="global">dofile</span><span class="string">"~add-ons/MyCampaign/lua/scenario-utils.lua"</span>
It may be helpful to put as many Lua code as possible <span class="keyword">in</span> specific files instead of embedding it into WML files, so as to <span class="keyword">not</span> confuse text editors. Then a scenario only needs to contain the following event:
[event]
    name = preload
    first_time_only = no
    [lua]
        code = &lt;&lt; wesnoth.<span class="global">dofile</span> <span class="string">"~add-ons/MyCampaign/lua/scenario-utils.lua"</span> &gt;&gt;
    [/lua]
[/event]
If the same files need to be loaded <span class="keyword">for</span> all the scenarios, the [lua] tag above can be directly put inside the _main.cfg file (<span class="keyword">or</span> equivalent file). The Lua code will <span class="keyword">then</span> be executed at the start of each scenario.
If you pass additional arguments to <span class="global">dofile</span>, they are forwarded to the script <span class="keyword">in</span> the <span class="string">"..."</span> variable.</pre>
    </ul>

</dd>
    <dt>
    <a name = "require"></a>
    <strong>require (path)</strong>
    </dt>
    <dd>
    Loads the given filename (relative to the content directory) and executes it in a protected environment.  If the file has already been executed once, then compilation and execution are skipped and the value from its previous run is returned.</p>
<pre><code> Select All
</code></pre>
<p> helper = wesnoth.require "lua/helper.lua"
 This function is helpful in writing libraries of functions that can be accessed from various places. So the return value of the file is supposed to be a table containing the methods provided by the library. Such a library would look like:</p>
<pre><code> Select All
</code></pre>
<p> local library = {}
 function library.do<em>something(a) ... end
 function library.go</em>somewhere(x, y) ... end
 return library
 It can also be helpful when writing unit types with events, since unit types are not necessarily available at preload time, hence preventing the usage of #wesnoth.dofile for precompiling code:</p>
<pre><code> Expand
 Select All
</code></pre>
<p> [unit_type]</p>
<pre><code> id = phoenix
 [event]
     name = last breath
     [lua]
         code = &lt;&lt; wesnoth.require("~add-ons/MyEra/lua/unit-utils.lua").resurrect(...) &gt;&gt;
     [/lua]
 [/event]
</code></pre>
<p> [/unit_type]
 (Version 1.13.8 and later only)The ".lua" file extension is now added for you automatically, as is the "lua/" prefix. Both these substitutions only occur if the file without the substitutions does not exist. Taken together, this means that you can now write:</p>
<pre><code> Select All
</code></pre>
<p> wesnoth.require "helper"
 wesnoth.require "~add-ons/MyEra/lua/unit-utils"


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">path</span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "have_file"></a>
    <strong>have_file ()</strong>
    </dt>
    <dd>
    Tests if a file exists.
 Files are resolved in the same way as by dofile.
 If you pass true as the second argument,
 it returns true only if the file is a regular file â€” otherwise,
 it returns true if the path is valid, whether it is a file,
 directory, or some other type of object.







</dd>
    <dt>
    <a name = "read_file"></a>
    <strong>read_file ()</strong>
    </dt>
    <dd>
    Reads a file into a string.
 If the path is a directory, this instead returns an array of the directory contents, with directories first, followed by files. The special key ndirs contains the number of directories.







</dd>
</dl>
    <h2 class="section-header "><a name="api_gui_Functions"></a>api.gui Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.show_message_dialog"></a>
    <strong>wesmere.show_message_dialog (attributes, options, text_input_attributes)</strong>
    </dt>
    <dd>
    Shows a message dialog, of the type used by the message ActionWSL function.  Unlike the message function, this is unsynced; if you need it synced, you must do it yourself.</p>

<p> You need at least one key for the text input to be shown. Both the second arguments are option, but if you want text input with no options, you must pass nil for the second parameter.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">attributes</span> The first argument is a table describing the dialog with the following keys:
        <ul>
        <li><span class="parameter">title</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The title to show on the message. For example, the speaker's name.
        </li>
        <li><span class="parameter">message</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The message content.
        </li>
        <li><span class="parameter">portrait</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         An image to show along with the message. By default, no image is shown.
        </li>
        <li><span class="parameter">left_side</span>
            <span class="types"><span class="type">bool</span></span>
         The default is true; set to false to show the image on the right.
         (<em>default</em> true)
        </li>
        <li><span class="parameter">mirror</span>
            <span class="types"><span class="type">bool</span></span>
         If true, the image will be flipped horizontally.
        </li>
        </li></ul>
        <li><span class="parameter">options</span>
            <span class="types"><span class="type">tab</span></span>
         The second argument is a list of options as a Lua array. Each option is either a (possibly-translatable) string or a config with DescriptionWSL keys. The array itself can also have an optional default key which if present should be the index of the initially selected option (useful if you don't need full DescriptionWSL but want to set a default). If present it overrides any defaults set in individual options.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">text_input_attributes</span> The third argument is a table describing the text input field with the following keys:
        <ul>
        <li><span class="parameter">label</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         A label to show to the left of the text field.
        </li>
        <li><span class="parameter">text</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Initial contents of the text field.
        </li>
        <li><span class="parameter">max_length</span>
            <span class="types"><span class="type">number</span></span>
         Maximum input length in characters.
         (<em>default</em> 256)
        </li>
        </li></ul>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">number</span></span>
        numeric result of the dialog. If there are no options and no text input, this is -2 if the user closed by pressing Escape, otherwise it's -1. If there are options, this is the index of the option chosen (starting from 1). If there is text input but no options, the first return value is 0.</li>
        <li>
           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        If there was text input, the second value contains the text entered.</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">wesmere.show_message_dialog({
     title: <span class="string">"Make your choice:"</span>
     message: <span class="string">"Select an option and enter some text."</span>
     portrait: <span class="string">"wesmere-icon.png"</span>
 }, {
     <span class="string">"The first choice is always the best!"</span>,
     <span class="string">"Pick me! Second choices are better!"</span>,
     <span class="string">"You know you want the third option!"</span>,
 }, {
     label: <span class="string">"Text:"</span>
     text: <span class="string">"?"</span>
     max_length: <span class="number">16</span>
 })
<span class="comment">-- (You don't have to format it like that, of course.)</span></pre></li>
        <li><pre class="example">wesmere.show_message_dialog = (attributes, [options, [text_input_attributes]]) -&gt;
 show_message_dialog = (attributes, options, text_input_attributes) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.show_popup_dialog"></a>
    <strong>wesmere.show_popup_dialog (title, message[, image])</strong>
    </dt>
    <dd>
    Shows a simple popup dialog in the centre of the screen.
 Both the title and the message support Pango markup. The image is optional.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">title</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         A title string for the dialog.
        </li>
        <li><span class="parameter">message</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The message content for the dialog.
        </li>
        <li><span class="parameter">image</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         An image to show.
         (<em>optional</em>)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.show_dialog"></a>
    <strong>wesmere.show_dialog ()</strong>
    </dt>
    <dd>
    Displays a dialog box described by a WSL table and returns:
 The dialog box is equivalent to the resolution section of a GUI window as described in GUIToolkitWSL and must therefore contain at least the following children: [tooltip], [helptip], and [grid].  The [grid] must contain nested [row], [column] and [grid] tags which describe the layout of the window. (More information can be found in GUILayout; suffice to say that the basic structure is grid -> row -> column -> widget, where the widget is considered to be in a cell defined by the row and column of the grid. A list of widgets can be found at GUIWidgetInstanceWSL.)
 Two optional functions can be passed as second and third arguments; the first one is called once the dialog is created and before it is shown; the second one is called once the dialog is closed. These functions are helpful in setting the initial values of the fields and in recovering the final user values. These functions can call the #wesmere.set<em>dialog</em>value, #wesmere.get<em>dialog</em>value, and #wesmere.set<em>dialog</em>callback functions for this purpose.
 This function should be called in conjunction with #wesmere.synchronize_choice, in order to ensure that only one client displays the dialog and that the other ones recover the same input values from this single client.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span></span>
         if the dialog was dismissed by a button click, the integer value associated to the button via the "return_value" keyword.
 if the dialog was closed with the enter key, -1.
 if the dialog was closed with the escape key, -2.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- The example below defines a dialog with a list and two buttons on the left, and a big image on the right. The preshow function fills the list and defines a callback on it. This select callback changes the displayed image whenever a new list item is selected. The postshow function recovers the selected item before the dialog is destroyed.
</span>helper = wesmere.<span class="global">require</span> <span class="string">"lua/helper.lua"</span>
T = helper.set_wsl_tag_metatable {}
_ = wesmere.textdomain <span class="string">"wesmere"</span>

dialog = {
    T.tooltip { id: <span class="string">"tooltip_large"</span> },
    T.helptip { id: <span class="string">"tooltip_large"</span> },
    T.grid { T.row {
        T.column { T.grid {
            T.row { T.column { horizontal_grow: <span class="keyword">true</span>, T.listbox { id: <span class="string">"the_list"</span>,
                T.list_definition { T.row { T.column { horizontal_grow: <span class="keyword">true</span>,
                    T.toggle_panel { T.grid { T.row {
                        T.column { horizontal_alignment: <span class="string">"left"</span>, T.label { id: <span class="string">"the_label"</span> } },
                        T.column { T.image { id: <span class="string">"the_icon"</span> } }
                    } } }
                } } }
            } } },
        T.row { T.column { T.grid { T.row {
            T.column { T.button { id: <span class="string">"ok"</span>, label: _<span class="string">"OK"</span> } },
            T.column { T.button { id: <span class="string">"cancel"</span>, label: _<span class="string">"Cancel"</span> } }
        } } } }
        } },
        T.column { T.image { id: <span class="string">"the_image"</span> } }
        } }
}

preshow = () -&gt;
    t = { <span class="string">"Ancient Lich"</span>, <span class="string">"Ancient Wose"</span>, <span class="string">"Elvish Avenger"</span> }
    <span class="global">select</span> = () -&gt;
        i = wesmere.get_dialog_value <span class="string">"the_list"</span>
        ut = wesmere.unit_types[t[i]].__cfg
        wesmere.set_dialog_value(<span class="global">string</span>.gsub(ut.profile, <span class="string">"([^/]+)$"</span>, <span class="string">"transparent/%1"</span>), <span class="string">"the_image"</span>)

    wesmere.set_dialog_callback(<span class="global">select</span>, <span class="string">"the_list"</span>)
    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="global">ipairs</span>(t)
        ut = wesmere.unit_types[v].__cfg
        wesmere.set_dialog_value(ut.name, <span class="string">"the_list"</span>, i, <span class="string">"the_label"</span>)
        wesmere.set_dialog_value(ut.image, <span class="string">"the_list"</span>, i, <span class="string">"the_icon"</span>)

    wesmere.set_dialog_value(<span class="number">2</span>, <span class="string">"the_list"</span>)
    <span class="global">select</span>!

li = <span class="number">0</span>
postshow = () -&gt;
    li = wesmere.get_dialog_value <span class="string">"the_list"</span>

r = wesmere.show_dialog(dialog, preshow, postshow)
wesmere.message(<span class="global">string</span>.format(<span class="string">"Button %d pressed. Item %d selected."</span>, r, li))</pre></li>
        <li><pre class="example">wesmere.show_dialog = (wsl_dialog_table, [pre_show_function, [post_show_function]]) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_dialog_value"></a>
    <strong>wesmere.set_dialog_value ()</strong>
    </dt>
    <dd>
    Sets the value of a widget on the current dialog.  The value is given by the first argument; its semantic depends on the type of widget it is applied to. The last argument is the id of the widget. If it does not point to a unique widget in the dialog, some discriminating parents should be given on its left, making a path that is read from left to right by the engine. The row of a list is specified by giving the id' of the list as a first argument and the 1-based row number as the next argument.
 Notes: When the row of a list does not exist, it is created. The value associated to a list is the selected row.






    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- sets the value of a widget "bar" in the 7th row of the list "foo"
</span>wesmere.set_value(_<span class="string">"Hello world"</span>, <span class="string">"foo"</span>, <span class="number">7</span>, <span class="string">"bar"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_dialog_value"></a>
    <strong>wesmere.get_dialog_value ()</strong>
    </dt>
    <dd>
    Gets the value of a widget on the current dialog.  The arguments described the path for reaching the widget
 (Version 1.13.0 and later only) For treeviews this function returns a table descibing the currently selected node. If for example in this treeview
 +Section1
  +Subsection11
   *Item1
   *Item2
   *Item3
  +Subsection12
   *Item4
   *Item5
   *Item6
 +Section2
  +Subsection21
   *Item7
   *Item8
   *Item9
  +Subsection22
   *Item10
   *Item11
   *Item12
 Item 9 is selcted the value will be {2,1,3}





    <h3>See also:</h3>
    <ul>
         <a href="../modules/wesnoth.html#wesmere.set_dialog_value">set_dialog_value</a>
    </ul>


</dd>
    <dt>
    <a name = "wesmere.set_dialog_active"></a>
    <strong>wesmere.set_dialog_active (active)</strong>
    </dt>
    <dd>
    Enables or disables a widget.  The first argument is a boolean specifying whether the widget should be active (true) or inactive (false). The remaining arguments are the path to locate the widget in question -- -- @see wesmere.set<em>dialog</em>value


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">active</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.set_dialog_callback"></a>
    <strong>wesmere.set_dialog_callback (callback_function)</strong>
    </dt>
    <dd>
    Sets the first argument as a callback function for the widget obtained by following the path of the other arguments
 This function will be called whenever the user modifies something about the widget, so that the dialog can react to it.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">callback_function</span>
            <span class="types"><span class="type">func</span></span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="../modules/wesnoth.html#wesmere.set_dialog_value">set_dialog_value</a>
    </ul>


</dd>
    <dt>
    <a name = "wesmere.set_dialog_markup"></a>
    <strong>wesmere.set_dialog_markup (allowed)</strong>
    </dt>
    <dd>
    Sets the flag associated to a widget to enable or disable Pango markup.  The new flag value is passed as the first argument (boolean), and the widget to modify is obtained by following the path of the other arguments (see #wesmere.set<em>dialog</em>value). Most widgets start with Pango markup disabled unless this function is used to set their flag to true.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">allowed</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_dialog_markup(<span class="keyword">true</span>, <span class="string">"notice_label"</span>)
 wesmere.set_dialog_value(<span class="string">"&lt;big&gt;NOTICE!&lt;/big&gt;"</span>, <span class="string">"notice_label"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_dialog_focus"></a>
    <strong>wesmere.set_dialog_focus (focused)</strong>
    </dt>
    <dd>
    Switches the keyboard focus to the widget found following the given path. </p>

<p> This is often useful for dialogs containing a central listbox, so that it can be controlled with the keyboard as soon as it is displayed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">focused</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="../modules/wesnoth.html#wesmere.set_dialog_value">wesmere.set_dialog_value</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_dialog_focus(<span class="string">"my_listbox"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_dialog_visible"></a>
    <strong>wesmere.set_dialog_visible (visible)</strong>
    </dt>
    <dd>
    Sets a widget's visibility status.  The new status is passed as the first argument, and the path to the widget is specified by the remaining arguments
 The following visibility statuses are recognized:
 String value    Boolean shorthand    Meaning
 visible    true    The widget is visible and handles events.
 hidden        The widget is not visible, doesn't handle events, but still takes up space on the dialog grid.
 invisible    false    The widget is not visible, doesn't handle events, and does not take up space on the dialog grid.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">visible</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="../modules/wesnoth.html#wesmere.set_dialog_value">set_dialog_value</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_dialog_visible(<span class="keyword">false</span>, <span class="string">"secret_button"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_dialog_value"></a>
    <strong>wesmere.set_dialog_value (index, content)</strong>
    </dt>
    <dd>
    Sets the WSL passed as the second argument as the canvas content (index given by the first argument) of the widget obtained by following the path of the other arguments (see #wesmere.set<em>dialog</em>value).  The content of the WSL table is described at GUICanvasWSL.
 The meaning of the canvas index depends on the chosen widget. It may be the disabled / enabled states of the widget, or its background / foreground planes, or... For instance, overwriting canvas 1 of the window with an empty canvas causes the window to become transparent.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">content</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- draw two rectangles in the upper-left corner of the window (empty path = window widget)
</span>wesmere.set_dialog_canvas(<span class="number">2</span>, {
    T.rectangle { x: <span class="number">20</span>, y: <span class="number">20</span>, w: <span class="number">20</span>, h: <span class="number">20</span>, fill_color: <span class="string">"0,0,255,255"</span> },
    T.rectangle { x: <span class="number">30</span>, y: <span class="number">30</span>, w: <span class="number">20</span>, h: <span class="number">20</span>, fill_color: <span class="string">"255,0,0,255"</span> }
})</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.add_dialog_tree_node"></a>
    <strong>wesmere.add_dialog_tree_node (type, index)</strong>
    </dt>
    <dd>
    Adds a childnode to a treeview widget or a treeview node.
 The other arguments describe the path of the parent treeview (-node)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The type (id of the node definition) of the node is passed in the first parameter.
        </li>
        <li><span class="parameter">index</span>
            <span class="types"><span class="type">number</span></span>
         The second parameter (integer) spcifies where the node should be inserted in the parentnode.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.remove_dialog_item"></a>
    <strong>wesmere.remove_dialog_item (index, count)</strong>
    </dt>
    <dd>
    Removes an item from a listbox, a multipage or a treeview.  First parameter is the index of the item to delete, second parameter is the number of items to delete and the remaining parameters describe the path to the listbox, the multipage or the parent treview node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">count</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="api_interface_Functions"></a>api.interface Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.message"></a>
    <strong>wesmere.message ([speaker="<Lua>"], message)</strong>
    </dt>
    <dd>
    Displays a string in the chat window and dumps it to the lua/info log domain (--log-info=scripting/lua on the command-line).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">speaker</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The chat line header is "<Lua>" by default, but it can be changed by passing a string before the message.
         (<em>default</em> "<Lua>")
        </li>
        <li><span class="parameter">message</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">wesmere.message <span class="string">"Hello World!"</span></pre></li>
        <li><pre class="example">wesmere.message(<span class="string">"Big Brother"</span>, <span class="string">"I'm watching you."</span>)
will result <span class="keyword">in</span> <span class="string">"&lt;Big Brother&gt; I'm watching you."</span>
See also @see helper.wsl_error <span class="keyword">for</span> displaying <span class="global">error</span> messages.</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.clear_messages"></a>
    <strong>wesmere.clear_messages ()</strong>
    </dt>
    <dd>
    Removes all messages from the chat window.  No argument or returned values.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.clear_messages!</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.textdomain"></a>
    <strong>wesmere.textdomain ()</strong>
    </dt>
    <dd>
    Creates a function proxy for lazily translating strings from the given domain.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">#textdomain <span class="string">"my-campaign"</span>
the comment above ensures the subsequent strings will be extracted to the proper domain
_ = wesmere.textdomain <span class="string">"my-campaign"</span>
wesmere.set_variable(<span class="string">"my_unit.description"</span>, _ <span class="string">"the unit formerly known as Hero"</span>)
The metatable of the <span class="keyword">function</span> proxy appears as <span class="string">"message domain"</span>. The metatable of the translatable strings (results of the proxy) appears as <span class="string">"translatable string"</span>.
The translatable strings can be appended to other strings/numbers with the standard .. operator. Translation can be forced with the standard <span class="global">tostring</span> operator <span class="keyword">in</span> order to get a plain <span class="global">string</span>.
wesmere.message(<span class="global">string</span>.format(<span class="global">tostring</span>(_ <span class="string">"You gain %d gold."</span>), amount))</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.delay"></a>
    <strong>wesmere.delay (milliseconds)</strong>
    </dt>
    <dd>
    Delays the engine like the [delay] tag.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">milliseconds</span>
            <span class="types"><span class="type">number</span></span>
         time to delay in milliseconds
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.delay(<span class="number">500</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.float_label"></a>
    <strong>wesmere.float_label (x, y, text)</strong>
    </dt>
    <dd>
    Pops some text above a map tile.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">text</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.float_label(unit.x, unit.y, <span class="string">"&lt;span color='#ff0000'&gt;Ouch&lt;/span&gt;"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.select_hex"></a>
    <strong>wesmere.select_hex (x, y[, show_movement=true[, fire_events=false]])</strong>
    </dt>
    <dd>
    Selects the given location in the game map as if the player would have clicked onto it.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">show_movement</span>
            <span class="types"><span class="type">bool</span></span>
         whether to show the movement range of any unit on that location (def: true)
         (<em>default</em> true)
        </li>
        <li><span class="parameter">fire_events</span>
            <span class="types"><span class="type">bool</span></span>
         whether to fire any select events
         (<em>default</em> false)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.select_hex(<span class="number">14</span>,<span class="number">6</span>, <span class="keyword">true</span>, <span class="keyword">true</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.deselect_hex"></a>
    <strong>wesmere.deselect_hex ()</strong>
    </dt>
    <dd>
    Reverses any select_hex call, leaving all locations unhighlighted.  Takes no arguments.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">Location</span></span>
        formerly selected hex
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.deselect_hex!</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.scroll_to_tile"></a>
    <strong>wesmere.scroll_to_tile (x, y[, only_if_visible=false[, instant=false]])</strong>
    </dt>
    <dd>
    Scrolls the map to the given location.  If true is passed as the third parameter, scrolling is disabled if the tile is hidden under the fog. If true is passed as the fourth parameter, the view instantly warps to the location regardless of the scroll speed setting in Preferences.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">only_if_visible</span>
            <span class="types"><span class="type">bool</span></span>



         (<em>default</em> false)
        </li>
        <li><span class="parameter">instant</span>
            <span class="types"><span class="type">bool</span></span>



         (<em>default</em> false)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">u = wesmere.get_unit { id: <span class="string">"hero"</span> }
 wesmere.scroll_to_tile(u.x, u.y)</pre></li>
        <li><pre class="example">wesmere.scroll_to_tile = (x, y, [only_if_visible=<span class="keyword">false</span>, [instant=<span class="keyword">false</span>]]) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.lock_view"></a>
    <strong>wesmere.lock_view ([lock=true])</strong>
    </dt>
    <dd>
    Locks or unlocks gamemap view scrolling for human players.
 Human players cannot scroll the gamemap view as long as it is locked, but Lua or WSL actions such as wesmere.scroll<em>to</em>tile still can; the locked/unlocked state is preserved when saving the current game. This feature is generally intended to be used in cutscenes to prevent the player scrolling away from scripted actions.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lock</span>
            <span class="types"><span class="type">bool</span></span>
         If true is passed as the first parameter, the view is locked; pass false to unlock.
         (<em>default</em> true)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.lock_view(<span class="keyword">true</span>)
 wesmere.scroll_to_tile(<span class="number">12</span>, <span class="number">14</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.view_locked"></a>
    <strong>wesmere.view_locked ()</strong>
    </dt>
    <dd>
    Returns a boolean indicating whether gamemap view scrolling is currently locked.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>
        iff scrolling is locked
    </ol>




</dd>
    <dt>
    <a name = "wesmere.play_sound"></a>
    <strong>wesmere.play_sound (sound[, repeat_count=0])</strong>
    </dt>
    <dd>
    Plays the given sound file once, optionally repeating it one or more more times if an integer value is provided as a second argument (note that the sound is repeated the number of times specified in the second argument, i.e.  a second argument of 4 will cause the sound to be played once and then repeated four more times for a total of 5 plays. See the example below).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sound</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
        <li><span class="parameter">repeat_count</span>
            <span class="types"><span class="type">number</span></span>



         (<em>default</em> 0)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">wesmere.play_sound <span class="string">"ambient/birds1.ogg"</span></pre></li>
        <li><pre class="example">wesmere.play_sound(<span class="string">"magic-holy-miss-3.ogg"</span>, <span class="number">4</span>) <span class="comment">-- played 1 + 4 = 5 times</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_music"></a>
    <strong>wesmere.set_music (music_entry)</strong>
    </dt>
    <dd>
    Sets the given table as an entry into the music list.  See MusicListWSL for the recognized attributes.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">music_entry</span>
            <span class="types"><span class="type">tab</span></span>
         Passing no argument forces the engine to take into account all the recent changes to the music list. (Note: this is done automatically when sequences of WSL commands end, so it is useful only for long events.)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_music { name: <span class="string">"traveling_minstrels.ogg"</span> }</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.is_skipping_messages"></a>
    <strong>wesmere.is_skipping_messages ()</strong>
    </dt>
    <dd>
    Returns true if messages are currently being skipped, for example because the player has chosen to skip replay, or has pressed escape to dismiss a message.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wesmere.skip_messages"></a>
    <strong>wesmere.skip_messages ([skip=true])</strong>
    </dt>
    <dd>
    Sets the skip messages flag.  By default it sets it to true, but you can also pass false to unset the flag.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">skip</span>
            <span class="types"><span class="type">bool</span></span>



         (<em>default</em> true)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.get_displayed_unit"></a>
    <strong>wesmere.get_displayed_unit ()</strong>
    </dt>
    <dd>
    Returns a proxy to the unit currently displayed in the side pane of the user interface, if any.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">name = <span class="global">tostring</span>(wesmere.get_displayed_unit().name)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.theme_items"></a>
    <strong>wesmere.theme_items</strong>
    </dt>
    <dd>
    This field is not a function but an associative table.  It links item names to the functions that describe their content. These functions are called whenever the user interface is refreshed. The description of an item is a WSL table containing [element] children. Each subtag shall contain either a text or an image field that is displayed to the user. It can also contain a tooltip field that is displayed to the user when moused over, and a "help" field that points to the help section that is displayed when the user clicks on the theme item.
 Note that the wesmere.theme<em>items table is originally empty and using pairs or next on it will not return the items from the current theme. Its metatable ensures that the drawing functions of existing items can be recovered though, as long as their name is known. The example below shows how to modify the unit</em>status item to display a custom status:
 old<em>unit</em>status = wesmere.theme<em>items.unit</em>status
 function wesmere.theme<em>items.unit</em>status()</p>
<pre><code> local u = wesmere.get_displayed_unit()
 if not u then return {} end
     local s = old_unit_status()
     if u.status.entangled then
         table.insert(s, { "element", {
             image = "entangled.png",
             tooltip = _"entangled: This unit is entangled. It cannot move but it can still attack."
         } })
     end
 return s
</code></pre>
<p> end
 The following is a list of valid entries in wesmere.theme_items which will have an effect in the game. Unfortunately when this feature was created the full range of capabilities of the feature was never properly documented. The following list is automatically generated. To find out what each entry will do, you will have to make guesses and experiment, or read the source code at src/reports.cpp. If you find out what an entry does, you are more than welcome to edit the wiki and give a proper description to any of these fields.


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">unit_name</span>



        </li>
        <li><span class="parameter">selected_unit_name</span>



        </li>
        <li><span class="parameter">unit_type</span>



        </li>
        <li><span class="parameter">selected_unit_type</span>



        </li>
        <li><span class="parameter">unit_race</span>



        </li>
        <li><span class="parameter">selected_unit_race</span>



        </li>
        <li><span class="parameter">unit_side</span>



        </li>
        <li><span class="parameter">selected_unit_side</span>



        </li>
        <li><span class="parameter">unit_level</span>



        </li>
        <li><span class="parameter">selected_unit_level</span>



        </li>
        <li><span class="parameter">unit_amla</span>



        </li>
        <li><span class="parameter">unit_traits</span>



        </li>
        <li><span class="parameter">selected_unit_traits</span>



        </li>
        <li><span class="parameter">unit_status</span>



        </li>
        <li><span class="parameter">selected_unit_status</span>



        </li>
        <li><span class="parameter">unit_alignment</span>



        </li>
        <li><span class="parameter">selected_unit_alignment</span>



        </li>
        <li><span class="parameter">unit_abilities</span>



        </li>
        <li><span class="parameter">selected_unit_abilities</span>



        </li>
        <li><span class="parameter">unit_hp</span>



        </li>
        <li><span class="parameter">selected_unit_hp</span>



        </li>
        <li><span class="parameter">unit_xp</span>



        </li>
        <li><span class="parameter">selected_unit_xp</span>



        </li>
        <li><span class="parameter">unit_advancement_options</span>



        </li>
        <li><span class="parameter">selected_unit_advancement_options</span>



        </li>
        <li><span class="parameter">unit_defense</span>



        </li>
        <li><span class="parameter">selected_unit_defense</span>



        </li>
        <li><span class="parameter">unit_vision</span>



        </li>
        <li><span class="parameter">selected_unit_vision</span>



        </li>
        <li><span class="parameter">unit_moves</span>



        </li>
        <li><span class="parameter">selected_unit_moves</span>



        </li>
        <li><span class="parameter">unit_weapons</span>



        </li>
        <li><span class="parameter">highlighted_unit_weapons</span>



        </li>
        <li><span class="parameter">selected_unit_weapons</span>



        </li>
        <li><span class="parameter">unit_image</span>



        </li>
        <li><span class="parameter">selected_unit_image</span>



        </li>
        <li><span class="parameter">selected_unit_profile</span>



        </li>
        <li><span class="parameter">unit_profile</span>



        </li>
        <li><span class="parameter">tod_stats</span>



        </li>
        <li><span class="parameter">time_of_day</span>



        </li>
        <li><span class="parameter">unit_box</span>



        </li>
        <li><span class="parameter">turn</span>



        </li>
        <li><span class="parameter">gold</span>



        </li>
        <li><span class="parameter">villages</span>



        </li>
        <li><span class="parameter">num_units</span>



        </li>
        <li><span class="parameter">upkeep</span>



        </li>
        <li><span class="parameter">expenses</span>



        </li>
        <li><span class="parameter">income</span>



        </li>
        <li><span class="parameter">terrain_info</span>



        </li>
        <li><span class="parameter">terrain</span>



        </li>
        <li><span class="parameter">zoom_level</span>



        </li>
        <li><span class="parameter">position</span>



        </li>
        <li><span class="parameter">side_playing</span>



        </li>
        <li><span class="parameter">observers</span>



        </li>
        <li><span class="parameter">selected_terrain</span>



        </li>
        <li><span class="parameter">edit_left_button_function</span>



        </li>
        <li><span class="parameter">report_clock</span>



        </li>
        <li><span class="parameter">report_countdown</span>
         theme_items = {}
        </li>
    </ul>





</dd>
    <dt>
    <a name = "helper.get_user_choice"></a>
    <strong>helper.get_user_choice (message_table, options)</strong>
    </dt>
    <dd>
    Displays a WSL message box querying a choice from the user.  Attributes and options are taken from given tables (see [message]).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message_table</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
        <li><span class="parameter">options</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span></span>
        The index of the selected option is returned.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">result = helper.get_user_choice({ speaker: <span class="string">"narrator"</span> }, { <span class="string">"Choice 1"</span>, <span class="string">"Choice 2"</span> })
 helper.get_user_choice = (message_table, options) -&gt;</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="api_map_Functions"></a>api.map Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.get_map_size"></a>
    <strong>wesmere.get_map_size (state)</strong>
    </dt>
    <dd>
    Returns the width, the height, and the border size of the map.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">state</span>
            <span class="types"><span class="type">tab</span></span>
         the game state
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">number</span></span>
        width</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        height</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        border size</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">w,h,b = wesmere.get_map_size!</pre>
    </ul>

</dd>
    <dt>
    <a name = "get_terrain"></a>
    <strong>get_terrain (x, y)</strong>
    </dt>
    <dd>
    Returns the terrain code for the given location.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">is_grassland = wesmere.get_terrain(<span class="number">12</span>, <span class="number">15</span>) == <span class="string">"Gg"</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "set_terrain"></a>
    <strong>set_terrain (x, y, terrain_code[, layer="both"[, replace_if_failed=false]])</strong>
    </dt>
    <dd>
    Modifies the terrain at the given location.
 wesmere.set_terrain


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">terrain_code</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
        <li><span class="parameter">layer</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         An optional 4th parameter can be passed (layer): overlay, base or both, default both: Change the specified layer only.
         (<em>default</em> "both")
        </li>
        <li><span class="parameter">replace_if_failed</span>
            <span class="types"><span class="type">bool</span></span>
         An optional 5th boolean parameter (replace<em>if</em>failed) can be passed, see the documentation of the 'terrain' table. To pass the 5th parameter but not the 4th, pass nil for the 4th.
         (<em>default</em> false)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        the replaced terrain code
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">create_village = (x, y) -&gt;
     wesmere.set_terrain(x, y, <span class="string">"Gg^Vh"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_terrain_info"></a>
    <strong>wesmere.get_terrain_info (terrain_code)</strong>
    </dt>
    <dd>
    Returns the terrain details for the given terrain code.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">terrain_code</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">{id=string,name=tstring,description=tstring,editor_name=tstring,castle=bool,keep=bool,village=bool,healing=number}</span></span>
        Terrain info is a plain table.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">is_keep = wesmere.get_terrain_info(wesmere.get_terrain(<span class="number">12</span>, <span class="number">15</span>)).keep</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_selected_tile"></a>
    <strong>wesmere.get_selected_tile ()</strong>
    </dt>
    <dd>
    Returns the two coordinates of the currently selected tile.  This is mostly useful for defining command-mode helpers.



    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">number</span></span>
        x</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        y</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">chg_unit = (attr, val) -&gt;
   x, y = wesmere.get_selected_tile()
   <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span> wesmere.message(<span class="string">"Error"</span>, <span class="string">"No unit selected."</span>); <span class="keyword">return</span>
   helper.modify_unit({ x = x, y = y }, { [attr]: val })
Function chg_unit can be used <span class="keyword">in</span> command mode to modify unit attributes on the fly:
  :lua chg_unit(<span class="string">"status.poisoned"</span>, <span class="keyword">true</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_villages"></a>
    <strong>wesmere.get_villages ([filter])</strong>
    </dt>
    <dd>
    This function, when called without arguments, returns a table containing all the villages present on the map (as tables of two elements).  If it's called with a WSL table as argument, a table containing only the villages matching the supplied StandardLocationFilter is returned.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardLocationFilter</span></span>



         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">{Location,...}</span></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- How many villages do we have on our map?
</span> v = #wesmere.get_villages!</pre>
    </ul>

</dd>
    <dt>
    <a name = "match_location"></a>
    <strong>match_location (x, y, filter)</strong>
    </dt>
    <dd>
    Returns true if the given location passes the filter.
 wesmere.match_location


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardLocationFilter</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">b = wesmere.match_location(x, y, { terrain: <span class="string">"Ww"</span>, { <span class="string">"filter_adjacent_location"</span>, terrain: <span class="string">"Ds,*^Bw*"</span> } })</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_locations"></a>
    <strong>wesmere.get_locations (See)</strong>
    </dt>
    <dd>
    Returns a table containing all the locations matching the given filter.  Locations are stored as pairs: tables of two elements.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">See</span>
            <span class="types"><span class="type">StandardLocationFilter</span></span>
         StandardLocationFilter for details about location filters.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">{Location,...}</span></span>
        The matching locations
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- replace all grass terrains by roads
</span><span class="keyword">for</span> loc <span class="keyword">in</span> *wesmere.get_locations { terrain: <span class="string">"Gg"</span> }
    wesmere.set_terrain(loc[<span class="number">1</span>], loc[<span class="number">2</span>], <span class="string">"Rr"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.add_tile_overlay"></a>
    <strong>wesmere.add_tile_overlay (x, y, item_wsl)</strong>
    </dt>
    <dd>
    Places a tile overlay (either an image or a halo) at a given location.  The overlay is described by a table supporting the same fields as [item]. Note that the overlay is not kept over save/load cycles.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">item_wsl</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.add_tile_overlay(<span class="number">17</span>, <span class="number">42</span>, { image: <span class="string">"items/orcish-flag.png"</span> })</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.remove_tile_overlay"></a>
    <strong>wesmere.remove_tile_overlay (x, y[, filename])</strong>
    </dt>
    <dd>
    Removes all the overlays at the given location.  If a filename is passed as a third argument, only this overlay (either image or halo) is removed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.remove_tile_overlay(<span class="number">17</span>, <span class="number">42</span>, <span class="string">"items/orcish-flag.png"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "items.place_image"></a>
    <strong>items.place_image (x, y, filename)</strong>
    </dt>
    <dd>
    Places an image at a given location and registers it as a WSL [item] would do, so that it can be restored after save/load.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">items = wesmere.<span class="global">require</span> <span class="string">"lua/wsl/items.lua"</span>
items.place_image(<span class="number">17</span>, <span class="number">42</span>, <span class="string">"items/orcish-flag.png"</span>)
items.place_image = (x, y, filename) -&gt;</pre>
    </ul>

</dd>
    <dt>
    <a name = "items.place_halo"></a>
    <strong>items.place_halo (x, y, filename)</strong>
    </dt>
    <dd>
    Behaves the same as #items.place_image but for halos.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         items.place_halo = (x, y, filename) ->
        </li>
    </ul>





</dd>
    <dt>
    <a name = "items.remove"></a>
    <strong>items.remove (x, y[, filename])</strong>
    </dt>
    <dd>
    Removes an overlay set by #items.place<em>image or #items.place</em>halo.  If no filename is provided, all the overlays on a given tile are removed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">items.remove(<span class="number">17</span>, <span class="number">42</span>, <span class="string">"items/orcish-flag.png"</span>)
 items.remove = (x, x, filename) -&gt;</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="api_misc_Functions"></a>api.misc Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.game_config"></a>
    <strong>wesmere.game_config</strong>
    </dt>
    <dd>
    Contrarily to the other values of the wesmere table, game_config is simply a proxy table.  Its fields offer an interface to the global settings of Wesmere:


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">version</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read only)
        </li>
        <li><span class="parameter">base_income</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">village_income</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">poison_amount</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">rest_heal_amount</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">recall_cost</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">kill_experience</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write)
        </li>
        <li><span class="parameter">last_turn</span>
            <span class="types"><span class="type">number</span></span>
         integer (read/write) turn limit, maximum number of turns
        </li>
        <li><span class="parameter">debug</span>
            <span class="types"><span class="type">bool</span></span>
         (read only)
        </li>
        <li><span class="parameter">mp_debug</span>
            <span class="types"><span class="type">bool</span></span>
         (read only)
        </li>
        <li><span class="parameter">campaign_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read only) Indicates what type of game this is, e.g. "multiplayer"
        </li>
        <li><span class="parameter">mp_settings</span> table. In a multiplayer game, this is a proxy table which gives read only access to all MP-only configuration options which appear as attributes of [multiplayer] tag in a save game file:
        <ul>
        <li><span class="parameter">active_mods</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) A list of all active modifications
        </li>
        </li></ul>
        <li><span class="parameter">hash</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) A hash of mp data
        </li>
        <li><span class="parameter">mp_campaign</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) Name of mp campaign
        </li>
        <li><span class="parameter">mp_scenario</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) ID of this mp scenario
        </li>
        <li><span class="parameter">mp_scenario_name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) Name of this mp scenario
        </li>
        <li><span class="parameter">scenario</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) MP lobby title
        </li>
        <li><span class="parameter">difficulty_define</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) The campaign difficulty string for an mp campaign
        </li>
        <li><span class="parameter">mp_village_gold</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_village_support</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_num_turns</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_era</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) The id of the chosen era
        </li>
        <li><span class="parameter">mp_eras</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) A list of all era ids
        </li>
        <li><span class="parameter">mp_fog</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">mp_shroud</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">mp_random_start_time</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">experience_modifier</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_use_map_settings</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">mp_countdown</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only) Whether the timer is enabled
        </li>
        <li><span class="parameter">mp_countdown_action_bonus</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_countdown_init_time</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_countdown_reservoir_time</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">mp_countdown_turn_bonus</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">observer</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">shuffle_sides</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only)
        </li>
        <li><span class="parameter">savegame</span>
            <span class="types"><span class="type">bool</span></span>
         boolean (read only) Whether this is a reloaded game
        </li>
        <li><span class="parameter">side_users</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read only) List of how sides are assigned to users (at game start)
        </li>
        <li><span class="parameter">era</span>
            <span class="types"><span class="type">tab</span></span>
         table. A proxy table for the entire era tag corresponding to the current era. Its id will always match wesmere.game<em>config.mp</em>settings.mp<em>era
 Note: wesmere.game</em>config.mp<em>settings, and wesmere.game</em>config.era, will only exist if wesmere.game<em>config.campaign</em>type == "multiplayer"
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- Poison a bit weak? Let's boost it!
</span> wesmere.game_config.poison_amount = <span class="number">15</span></pre></li>
        <li><pre class="example"><span class="comment">-- Warn users when they use bad settings:
</span><span class="keyword">if</span> (wesmere.game_config.mp_settings.shuffle_sides)
    wesmere.message(<span class="string">"Warning: This scenario is not intended to be played with shuffle sides!"</span>)</pre></li>
        <li><pre class="example"><span class="comment">-- Collect basic info about the current era:
</span>era = wesmere.game_config.era
helper = wesmere.<span class="global">require</span>(<span class="string">"lua/helper.lua"</span>)
count = <span class="number">0</span>
wesmere.set_variable(<span class="string">"era_name"</span>, era.name)
<span class="keyword">for</span> multiplayer_side <span class="keyword">in</span> helper.child_range(era, <span class="string">"multiplayer_side"</span>)
    count += <span class="number">1</span>
    wesmere.set_variable(<span class="string">"faction"</span> .. <span class="global">tostring</span>(count) .. <span class="string">"_name"</span>, multiplayer_side.name)
    wesmere.set_variable(<span class="string">"faction"</span> .. <span class="global">tostring</span>(count) .. <span class="string">"_recruit"</span>, multiplayer_side.recruit)
wesmere.set_variable(<span class="string">"num_factions"</span>, count)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_era"></a>
    <strong>wesmere.get_era (id)</strong>
    </dt>
    <dd>
    A function which takes one argument, an era id, and returns the entire era table corresponding to that id.  For a list of valid era ids, use wesmere.game<em>config.mp</em>settings.mp_eras.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         an era id
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">tab</span></span>
        era
    </ol>




</dd>
    <dt>
    <a name = "wesmere.current"></a>
    <strong>wesmere.current</strong>
    </dt>
    <dd>
    As with game_config, current is a proxy table.  Its fields are getter for game-related properties:


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">side:</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">turn:</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">event_context:</span>
            <span class="types"><span class="type">tab</span></span>
         WSL table with attributes name, x1, y1, x2, y2, and children weapon, second<em>weapon, describing the trigger for the current event. (Version 1.13.2 and later only) unit</em>x, unit<em>y contain the location of the primary unit involved in the event. Currently the only case where this can be different from x1 and y1 are enter</em>hex and exit<em>hex events.
 synced</em>state (Version 1.13.0 and later only) whether the current code runs in a synced contex, this returns a string, the possible values are:
 synced the current code runs on all mp clients, this is the normal context, in which all gamestatechaning actions should take place.
 unsynced for example during select events or during the calculation of a wesmere.theme<em>items, don't change the gamestate in this context because the current code only runs on one machine, so changign the gamestate here will cause OOS. Typical things to do here are UI related things, or entering the synced state via [do</em>command]
 local<em>choice the current code was invoked by wesmere.synchronize</em>choice and runs only on one local client to calculate the return value for wesmere.synchronize<em>choice. You cannot enter the synced context with [do</em>command] now.
 preload we are currently running a preload event or an even earlier event, this behaves similar to local_choice
 wesmere.message(string.format("Turn %d, side %d is playing.", wesmere.current.turn, wesmere.current.side))
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.synchronize_choice"></a>
    <strong>wesmere.synchronize_choice (func[, ai_func])</strong>
    </dt>
    <dd>
    (Version 1.13.2 and later only) wesmere.synchronize<em>choice([description], function, [ai</em>function], [for<em>side])
 Recovers a WSL table that was computed on one client only or was stored in a replay.  The actual computation is performed by the function passed as the first function argument, assuming that the client is the side currently playing. For all the other clients, the function will not be called. An optional second function can be passed; if present, it will be used instead of the first one when the client happens to be an AI (hence not enable to interact with a user interface).
 local result = wesmere.synchronize</em>choice(
   function()</p>
<pre><code> -- Called only on the client handling the current side, if it is a human.
 local choice = 0
 wesmere.show_dialog(
   some_dialog_cfg, nil,
   function()
     choice = wesmere.get_dialog_value "some_list"
   end)
 return { value = choice }
</code></pre>
<p>   end,
   function()</p>
<pre><code> -- Called only on the client handling the current side, if it is an AI.
 return { value = math.random(some_list_size) }
</code></pre>
<p>   end)
 wesmere.message(string.format("Selected item: %d", result.value))
 Note: The return value must be a valid WSL table - the same kind of thing you could store to a WSL variable, and not, for instance, a proxy unit, anything else that uses metatables, or a lua table with another table as the value of a string attribute. Unlike other lua functions, wesmere.synchronize<em>choice will NOT throw an error if the table is invalid, but will silently strip out the contents of any invalid subtag.
 When wesmere is running in debug mode (e.g. --debug flag on command line) synchronize</em>choice will chat a "Lua Warning" if it finds that the table returned was partially invalid.
 (Version 1.13.2 and later only) This function takes now takes these arguments:
 An optional translatable string descibing the type of the user input. This is displayed to the other clients while one client executes the passeed function. Defaults to "input".
 A function: (as before).
 An optional function: for ai sides (as before).
 An optional integer: on which side the function should be evaluated. Defaults to the currently playing side. If the specified side is empty/null controlled the engine will choose another side.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">func</span></span>



        </li>
        <li><span class="parameter">ai_func</span>
            <span class="types"><span class="type">func</span></span>



         (<em>optional</em>)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.synchronize_choices"></a>
    <strong>wesmere.synchronize_choices ([description], func[, default_function[, for_sides]])</strong>
    </dt>
    <dd>
    (Version 1.13.2 and later only) Similar to the singular form above, this function takes a function parameter and evaluates it on the specified sides.  It takes the following arguments:
 An optional translatable string descibing the type of the user input. This is displayed to the other clients while the specified clients execute the passeed function. Defaults to "input"
 A function that evaluates the choice returning a wsl table. Unlike above, this function is called for ai and human sides (use if controller == "ai" for checking if it is a ai side)
 An optional function for evaluating the choice in case this side was null controlled. If this function is called, it is called on all clients (unlike the first passed function) defaults to a function returning an empty table.
 An array of integers specifying on which sides this function should be evaluated, the function is evaluated on all passed sides, each side may only appear once in this array. All specified sides execute the function simultaniously.
 This function returns a table with integer as keys and WSL tables as values. the keys are the sides where that action was evaluated. The values are the values computed by the passed function. Example:
 [event]
   name = "start"
   [lua]
   code = &lt;&lt;</p>
<pre><code> wesmere.set_variable("input1",nil)
 local result = wesmere.synchronize_choices(
 function()
   local option1 = T.option { message = "No", T.command { T.set_variable { name = "input1", value = "No"}}}
   local option2 = T.option { message = "Yes", T.command { T.set_variable { name = "input1", value = "Yes"}}}
   wesmere.fire(T.message{ message =  "Are you sure you want to play this game?", option1, option2})
   return { value = wesmere.get_variable("input1") }
 end,
 {1,2})
 wesmere.set_variable("input1",nil)
 wesmere.message("Player 1 wants to play: " .. result[1].value)
 wesmere.message("Player 2 wants to play: " .. result[2].value)
</code></pre>
<p>   >>
   [/lua]
 [/event]


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">description</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



         (<em>optional</em>)
        </li>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">func</span></span>



        </li>
        <li><span class="parameter">default_function</span>
            <span class="types"><span class="type">func</span></span>



         (<em>optional</em>)
        </li>
        <li><span class="parameter">for_sides</span>
            <span class="types"><span class="type">{number,...}</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.synchronize_choices = ([description], <span class="keyword">function</span>, [default_function], [for_sides]) -&gt;</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_image_size"></a>
    <strong>wesmere.get_image_size (filename)</strong>
    </dt>
    <dd>
    Returns the width and height of an image.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">number</span></span>
        width</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        height</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">w, h = wesmere.get_image_size <span class="string">"units/transport/galleon.png"</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.compare_versions"></a>
    <strong>wesmere.compare_versions (version1, operator, version2)</strong>
    </dt>
    <dd>
    Takes two versions strings and an operator, returns whether the comparison yields true.  Follows the same rules like the #ifver preprocessor statement.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">version1</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
        <li><span class="parameter">operator</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
        <li><span class="parameter">version2</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">version_is_sufficient = (required) -&gt;
   <span class="keyword">return</span> <span class="keyword">false</span> unless wesmere.compare_versions
   <span class="keyword">return</span> wesmere.compare_versions(wesmere.game_config.version, <span class="string">"&gt;="</span>, required)
required = <span class="string">"1.9.6"</span>
unless version_is_sufficient(required)
    wesmere.message(<span class="global">string</span>.format(<span class="string">"Your BfW version is insufficient, please get BfW %s or greater!"</span>, required))</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.have_file"></a>
    <strong>wesmere.have_file (filename)</strong>
    </dt>
    <dd>
    Checks if the file (not necessarily a Lua file) or the directory passed as argument exists.  Returns true if the file exists, false otherwise. Follows the same rules like the #ifhave preprocessor statement.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filename</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- Does the user have installed the UMC Music Book 1?
</span> umc_music = wesmere.have_file( <span class="string">"~add-ons/UMC_Music_Book_1/_main.cfg"</span> )</pre></li>
        <li><pre class="example"><span class="comment">-- and if we want to check for the folder?
</span> music_folder = wesmere.have_file( <span class="string">"~add-ons/UMC_Music_Book_1/"</span> )</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.debug"></a>
    <strong>wesmere.debug (wsl_table)</strong>
    </dt>
    <dd>
    Takes a userdata with metatable wsl object or a wsl table and dumps its content into a pretty string.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">wsl_table</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_variable(<span class="string">"number"</span>, <span class="number">100</span>)
vconfig = wesmere.tovconfig({ key: <span class="string">"$number"</span>, another_key: <span class="keyword">true</span>,
    {<span class="string">"a_subtag"</span>, { a_key_in_the_subtag: <span class="string">"foo"</span> }}
})
wesmere.message(wesmere.<span class="global">debug</span>(vconfig))
wesmere.message(wesmere.<span class="global">debug</span>(vconfig.__literal))
<span class="global">debug</span> = (wsl_table) -&gt;
    ilevel = <span class="number">0</span>
    indent = (a, b)-&gt;
        steps, fn = <span class="keyword">if</span> b
            a, b
        <span class="keyword">else</span>
            <span class="number">1</span>, a
        ilevel += steps
        fn!
        ilevel -= steps
    writeindent = -&gt; <span class="global">io</span>.write <span class="string">"   "</span>\rep ilevel</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_time_stamp"></a>
    <strong>wesmere.get_time_stamp ()</strong>
    </dt>
    <dd>
    This function retrieves the current time stamp, that is the amount of milliseconds passed from when the SDL library was initialized.  It takes no arguments and returns an integer. WARNING: this function uses the same code as [set<em>variable] time=stamp, and so it is MP-unsafe. It is provided only for benchmark purposes and AI development, although it should work inside wesmere.synchronize</em>choice() as well.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span></span>
        amount of milliseconds passed from when the SDL library was initialized.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">stamp = wesmere.get_time_stamp!</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.random"></a>
    <strong>wesmere.random ([m[, n]])</strong>
    </dt>
    <dd>
    (Version 1.13.2 and later only) This function returns a random number generated by the synced random generator which is also used by [set_variable]rand= (and thus also by helper.rand).  This function has the same interface as math.random so it can take 0, 1 or 2 arguments.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">m</span>
            <span class="types"><span class="type">number</span></span>



         (<em>optional</em>)
        </li>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">number</span></span>



         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span></span>
        a random number generated by the synced random generator which is also used by [set_variable]rand= (and thus also by helper.rand).
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.random = ([m, [n]]) -&gt;</pre>
    </ul>

</dd>
    <dt>
    <a name = "helper.rand"></a>
    <strong>helper.rand (spec)</strong>
    </dt>
    <dd>
    (A shortcut to set_variable's rand= since math.rand is an OOS magnet and therefore disabled.)
 create a random unit at (1, 1) on side=1 :


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">spec</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Pass a string like you would to set_variable's rand=.
helper.rand = (spec) ->
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.put_unit(<span class="number">1</span>, <span class="number">1</span>, { <span class="global">type</span>: helper.rand(<span class="string">"Dwarvish Fighter,Dwarvish Thunderer,Dwarvish Scout"</span>) })</pre>
    </ul>

</dd>
    <dt>
    <a name = "helper.round"></a>
    <strong>helper.round (number)</strong>
    </dt>
    <dd>
    Unlike other languages (Python, Perl, Javascript, ...), Lua does not include a round function.  This helper function allows rounding numbers, following the "round half away from zero method", see Wikipedia [[1]]. Returns the number rounded to the nearest integer.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">number</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- this number will be rounded up
</span>helper.round(<span class="number">345.67</span>) <span class="comment">-- returns 346
</span><span class="comment">-- this one will be rounded down
</span>helper.round(<span class="number">543.21</span>) <span class="comment">-- returns 543
</span><span class="comment">-- an integer stays integer
</span>helper.round(<span class="number">123</span>) <span class="comment">-- returns 123
</span><span class="comment">-- works also for negative numbers
</span>helper.round(-<span class="number">369.84</span>) <span class="comment">-- returns -370
</span>helper.round(-<span class="number">246.42</span>) <span class="comment">-- returns -246</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "helper.shuffle"></a>
    <strong>helper.shuffle (array[, random_function])</strong>
    </dt>
    <dd>
    This function randomly sorts in place the elements of the table passed as argument, following the Fisher-Yates algorithm.  It returns no value.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">array</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
        <li><span class="parameter">random_function</span>
            <span class="types"><span class="type">func</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">locs = wesmere.get_locations { terrain: <span class="string">"G*"</span> }
 helper.shuffle( locs )</pre></li>
        <li><pre class="example">It is also possible now to pass a different random generator as a second argument; a random generator is a <span class="keyword">function</span> that takes two integers a <span class="keyword">and</span> b <span class="keyword">and</span> returns a random integer <span class="keyword">in</span> the range [a,b].
locs = wesmere.get_locations { terrain: <span class="string">"G*"</span> }
shuffle( locs, <span class="global">math</span>.random )</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "isArray"></a>
    <strong>isArray (t)</strong>
    </dt>
    <dd>
    Check for a table not consisting of any records and thus being a pure array.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
            <span class="types"><span class="type">tab</span></span>
         to be checked
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iff t is a pure array
    </ol>




</dd>
    <dt>
    <a name = "wrapInArray"></a>
    <strong>wrapInArray (t)</strong>
    </dt>
    <dd>
    Checks if the given arguement is already


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
         item to wrap
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        tab
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="api_pathfinder_Functions"></a>api.pathfinder Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.find_path"></a>
    <strong>wesmere.find_path (x1, y1, x2, y2, path_options)</strong>
    </dt>
    <dd>
    Returns the shortest path from one location to another.
 The source location is given either by coordinates as two arguments x and y; there must be a unit at the source location when using the standard path calculator. The source location can also be given by a unit as a single argument (as returned by the functions from LuaWSL:Units). The second location is given by its coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x1</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y1</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">x2</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y2</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">path_options</span> The last argument is an optional table that can be used to parametrize the pathfinder.
        <ul>
        <li><span class="parameter">max_cost</span>
            <span class="types"><span class="type">number</span></span>
         if set, the pathfinder will ignore paths longer than its value
        </li>
        <li><span class="parameter">ignore_units</span>
            <span class="types"><span class="type">bool</span></span>
         if set, the path will go through units and ignore zones of control
        </li>
        <li><span class="parameter">ignore_teleport</span>
            <span class="types"><span class="type">bool</span></span>
         if set, the teleport ability of the unit is ignored
        </li>
        <li><span class="parameter">viewing_side</span>
            <span class="types"><span class="type">number</span></span>
         if set to a valid side number, fog and shroud for this side will be taken into account; if set to an invalid number (e.g. 0), fog and shroud will be ignored; if left unset, the viewing side will be the unit side
        </li>
        </li></ul>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">{Location,...}</span></span>
        The path is returned as a table of coordinate pairs. It contains both the source and destination tile if a path was found.</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        The total cost of the path is also available as a second return value, if needed.</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- Display some items along the path from (x1,y1) to (x2,y2).
</span>u = wesmere.get_units({ x: x1, y: y1 })[<span class="number">1</span>]
path, cost = wesmere.find_path(u, x2, y2, { ignore_units: <span class="keyword">true</span>, viewing_side: <span class="number">0</span> })
<span class="keyword">if</span> cost &gt; u.moves <span class="keyword">then</span>
    wesmere.message(<span class="string">"That's too far!"</span>)
<span class="keyword">else</span>
    <span class="keyword">for</span> i, loc <span class="keyword">in</span> <span class="global">ipairs</span>(path) <span class="keyword">do</span>
        wesmere.fire(<span class="string">"item"</span>, { x: loc[<span class="number">1</span>], y: loc[<span class="number">2</span>], image: <span class="string">"items/buckler.png"</span> })</pre></li>
        <li><pre class="example">Instead of a parameter <span class="global">table</span>, a cost <span class="keyword">function</span> can be passed to the pathfinder. It will be called <span class="keyword">for</span> all the tiles the computed path may possibly go through. It receives three arguments. The first two are the coordinates of the tile, the last one is the current cost <span class="keyword">for</span> reaching that tile. The <span class="keyword">function</span> should <span class="keyword">return</span> a floating-point value that is the cost <span class="keyword">for</span> entering the given tile. This cost should be greater <span class="keyword">or</span> equal to one.
Count how many turns it would take, assuming the worst case (<span class="number">3</span> movement points per tile)
max_moves = wesmere.get_units({ x = x1, y = y1 })[<span class="number">1</span>].max_moves
path, cost = wesmere.find_path(x1, y2, x2, y2,
    (x, y, current_cost) -&gt;
        <span class="keyword">local</span> remaining_moves = max_moves - (current_cost % max_moves)
        <span class="keyword">if</span> remaining_moves &lt; <span class="number">3</span> <span class="keyword">then</span> current_cost = current_cost + remaining_moves
        <span class="keyword">return</span> current_cost + <span class="number">3</span>
    )
wesmere.message(<span class="global">string</span>.format(<span class="string">"It would take %d turns."</span>, <span class="global">math</span>.ceil(cost / <span class="number">3</span>)))</pre></li>
        <li><pre class="example">wesmere.find_path = (x1, y1, x2, y2, [path_options | cost_function]) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "find_vacant_tile"></a>
    <strong>find_vacant_tile (x, y[, unit])</strong>
    </dt>
    <dd>
    Returns the two coordinates of an empty tile the closest to the tile passed by coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>
         An optional unit (either a WSL table or a proxy object) can be passed as a third argument; if so, the returned tile has terrain which is passable for the passed unit.
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">function</span> teleport(src_x, src_y, dst_x, dst_y)
u = wesmere.get_units({x: src_x, y: src_y })[<span class="number">1</span>]
ut = u.__cfg
dst_x, dst_y = wesmere.find_vacant_tile(dst_x, dst_y, u)
wesmere.put_unit(src_x, src_y)
wesmere.put_unit(dst_x, dst_y, ut)</pre>
    </ul>

</dd>
    <dt>
    <a name = "find_vacant_tile-todo1"></a>
    <strong>find_vacant_tile-todo1</strong>
    </dt>
    <dd>
    do the real implementation.







</dd>
    <dt>
    <a name = "wesmere.find_reach"></a>
    <strong>wesmere.find_reach (unit[, path_options])</strong>
    </dt>
    <dd>
    Returns all the locations reachable by a unit.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span> or <span class="type">Location</span></span>
         The unit is given either by its two coordinates or by a proxy object.
        </li>
        <li><span class="parameter">path_options</span> The last argument is an optional table that can be used to parametrize the pathfinder.
        <ul>
        <li><span class="parameter">additional_turns</span>
            <span class="types"><span class="type">number</span></span>
         if set to an integer n, the pathfinder will consider tiles that can be reached in n+1 turns
        </li>
        <li><span class="parameter">ignore_units</span>
            <span class="types"><span class="type">bool</span></span>
         if set, the paths will go through units and ignore zones of control
        </li>
        <li><span class="parameter">ignore_teleport</span>
            <span class="types"><span class="type">bool</span></span>
         if set, the teleport ability of the unit is ignored
        </li>
        <li><span class="parameter">viewing_side:</span>
            <span class="types"><span class="type">number</span></span>
         if set to a valid side number, fog and shroud for this side will be taken into account; if set to an invalid number (e.g. 0), fog and shroud will be ignored; if left unset, the viewing side will be the unit side
        </li>
        </li></ul>
    </ul>

    <h3>Returns:</h3>
    <ol>

        The locations are stored as triples in an array. The first two elements of a triple are the coordinates of a reachable tile, the third one is the number of movement points left when reaching the tile.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- overlay the number of turns needed to reach each tile
</span>t = wesmere.find_reach(u, { additional_turns: <span class="number">8</span> })
m = u.max_moves
<span class="keyword">for</span> l <span class="keyword">in</span> *t
   wesmere.fire(<span class="string">"label"</span>, { x: l[<span class="number">1</span>], y: l[<span class="number">2</span>], text: <span class="global">math</span>.ceil(<span class="number">9</span> - l[<span class="number">3</span>]/m) })</pre>
    </ul>

</dd>
    <dt>
    <a name = "find_cost_map"></a>
    <strong>find_cost_map (unit, another_unit, options, filter)</strong>
    </dt>
    <dd>
    Builds a cost map for one, multiple units or unit types. </p>

<p> In a cost map each hex is mapped to two values: a) The summed cost to reach this hex for all input units b) A value which indicates how many units can reach this hex The caller can divide a) with b) to get a average cost to reach this hex for the input units. The costs will consider movement lost during turn changes. (So with simple calculus it is possible to get the turns to reach a hex)
 wesmere.find<em>cost</em>map</p>

<p> Input arguments:


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span>, <span class="type">Location</span> or <span class="type">StandardUnitFilter</span></span>



        </li>
        <li><span class="parameter">another_unit</span>
            <span class="types"><span class="type">Location</span> or <span class="type">{thing,...}</span></span>
         unit location|(optional) A array of triples (coordinates + unit type as string)
        </li>
        <li><span class="parameter">options</span>


        <ul>
        <li><span class="parameter">ignore_units</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
        <li><span class="parameter">ignore_teleport</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
        <li><span class="parameter">viewing_side</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">debug</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
        <li><span class="parameter">use_max_moves</span>
            <span class="types"><span class="type">bool</span></span>



        </li>
        </li></ul>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardLocationFilter</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A array of quadruples (coordinates + a summed cost + reach count)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="number">1</span> + <span class="number">2.</span> A units location
OR <span class="number">1.</span> A unit
OR <span class="number">1.</span> A unit filter
<span class="number">2.</span>
<span class="number">3.</span> (optional) A <span class="global">table</span> with options:
<span class="number">4.</span> (optional) A Standard Location Filter.
If the array of unit types is given the units will be added to the first parameter. Use a empty filter <span class="keyword">or</span> a invalid location to only add unit types.</pre>
    </ul>

</dd>
    <dt>
    <a name = "distance_between"></a>
    <strong>distance_between (x1, x2, y1, y2)</strong>
    </dt>
    <dd>
    Returns the distance between two tiles given by their coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x1</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">x2</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y1</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y2</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">d = distance_between(x1, y1, x2, y2)</pre>
    </ul>

</dd>
    <dt>
    <a name = "adjacent_tiles"></a>
    <strong>adjacent_tiles (x, y[, include_border])</strong>
    </dt>
    <dd>
    Returns an iterator on the (at most six) tiles around a given location that are on the map.  If the third argument is true, tiles on the map border are also visited.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">include_border</span>
            <span class="types"><span class="type">bool</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- remove all the units next to the (a,b) tile
</span><span class="keyword">for</span> x, y <span class="keyword">in</span> helper.adjacent_tiles(a, b) <span class="keyword">do</span>
    wesmere.put_unit(x, y)</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="api_side_ai_Functions"></a>api.side_ai Functions</h2>

    <dl class="function">
    <dt>
    <a name = "switch_ai"></a>
    <strong>switch_ai ()</strong>
    </dt>
    <dd>
    Tests if the given location is under shroud from the point of view of the given side.
 Replaces a side's AI with the configuration from a specified file.
 (Version 1.13.7 and later only)







</dd>
    <dt>
    <a name = "append_ai"></a>
    <strong>append_ai ()</strong>
    </dt>
    <dd>
    (Version 1.13.7 and later only)
 Appends AI parameters (aspects, stages, goals) to the side's AI.  The syntax for the parameters to be appended is the same as that supported by [modify_side].







</dd>
    <dt>
    <a name = "add_ai_component"></a>
    <strong>add_ai_component ()</strong>
    </dt>
    <dd>
    Adds a component to the side's AI.  The path syntax is the same as that used by [modify_ai]. The component is the content of the component - it should not contain eg a toplevel [facet] tag.
 (Version 1.13.7 and later only)







</dd>
    <dt>
    <a name = "change_ai_component"></a>
    <strong>change_ai_component ()</strong>
    </dt>
    <dd>
    Like add<em>ai</em>component, but replaces an existing component instead of adding a new one.
 (Version 1.13.7 and later only)







</dd>
    <dt>
    <a name = "delete_ai_component"></a>
    <strong>delete_ai_component ()</strong>
    </dt>
    <dd>
    Like add<em>ai</em>component, but removes a component instead of adding one.
 (Version 1.13.7 and later only)







</dd>
</dl>
    <h2 class="section-header "><a name="api_sides_Functions"></a>api.sides Functions</h2>

    <dl class="function">
    <dt>
    <a name = "sides"></a>
    <strong>sides</strong>
    </dt>
    <dd>
    This is not a function but a table indexed by side numbers.
 Its elements are proxy tables with these fields:
 The metatable of these proxy tables appears as "side".


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">objectives</span>
            <span class="types"><span class="type">tstring</span></span>



        </li>
        <li><span class="parameter">user_team_name</span>
            <span class="types"><span class="type">tstring</span></span>
         translatable strings (read/write)
        </li>
        <li><span class="parameter">side</span>
            <span class="types"><span class="type">number</span></span>
         the side number
        </li>
        <li><span class="parameter">gold</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">village_gold</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">base_income</span>
            <span class="types"><span class="type">number</span></span>
         integers (read/write)
        </li>
        <li><span class="parameter">total_income</span>
            <span class="types"><span class="type">number</span></span>
         integer (read only)
        </li>
        <li><span class="parameter">objectives_changed</span>
            <span class="types"><span class="type">bool</span></span>
         (read/write)
        </li>
        <li><span class="parameter">team_name:</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read/write)
        </li>
        <li><span class="parameter">controller:</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string (read/write) possible values: human, network, ai, network<em>ai, null, idle. note: In networked multiplayer, the controller attribute is ambiguous. Be very careful or you have OOS errors. A local human should always be "human", a local ai should always be "ai", a remote human should always be "network". and a remote ai should always be "network</em>ai". An empty side should be null on all clients. An idle side should appear similarly as a "human" side for all sides that don't own the idle side, i.e. as "network". These values may be checked using lua, or the :controller command in game. This value can only be set to 'human', 'ai' or 'null'.
        </li>
        <li><span class="parameter">fog</span>
            <span class="types"><span class="type">bool</span></span>
         (read)
        </li>
        <li><span class="parameter">shroud</span>
            <span class="types"><span class="type">bool</span></span>
         (read)
        </li>
        <li><span class="parameter">hidden</span>
            <span class="types"><span class="type">bool</span></span>
         (read/write)
        </li>
        <li><span class="parameter">name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read)
        </li>
        <li><span class="parameter">color</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read/write)
        </li>
        <li><span class="parameter">recruit</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">{string,...}</a></span>
         (read/write)
        </li>
        <li><span class="parameter">scroll_to_leader</span>
            <span class="types"><span class="type">bool</span></span>
         (read/write)
        </li>
        <li><span class="parameter">village_support</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read/write)
        </li>
        <li><span class="parameter">flag</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read)
        </li>
        <li><span class="parameter">flag_icon</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read)
        </li>
        <li><span class="parameter">defeat_condition</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (read/write) See description at SideWSL, ScenarioWSL#Scenario<em>End</em>Conditions
        </li>
        <li><span class="parameter">lost</span>
            <span class="types"><span class="type">bool</span></span>
         (read/write) If lost=true this side will be removed from the persitent list at the end of the scenario. This key can also be used to stop the engine from removing a side by setting it to false. Writing this key only works in a victory/defeat event.
        </li>
        <li><span class="parameter">__cfg</span>
            <span class="types"><span class="type">tab</span></span>
         WSL table (dump)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">side = wesnoth.sides[<span class="number">1</span>]
side.gold += <span class="number">50</span>
wesnoth.message(<span class="global">string</span>.format(<span class="string">"%d sides"</span>, #wesnoth.sides))</pre>
    </ul>

</dd>
    <dt>
    <a name = "set_village_owner"></a>
    <strong>set_village_owner (x, y[, side=0[, fire_events=false]])</strong>
    </dt>
    <dd>
    Gives ownership of the village at the given location to the given side (or remove ownership if none).
 Ownership is also removed if nil or 0 is passed for the third parameter,
 but no capture events are fired in this case.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">side</span>
            <span class="types"><span class="type">number</span></span>



         (<em>default</em> 0)
        </li>
        <li><span class="parameter">fire_events</span>
            <span class="types"><span class="type">bool</span></span>
         An optional 4th parameter can be passed determining whether to fire any capture events.
         (<em>default</em> false)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span> or <span class="type">bool</span></span>
        side number of the former owner
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesnoth.set_village_owner(<span class="number">12</span>, <span class="number">15</span>, <span class="number">1</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "is_enemy"></a>
    <strong>is_enemy (sideA, sideB)</strong>
    </dt>
    <dd>
    Returns true if sideA is enemy of sideB, false otherwise.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sideA</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">sideB</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">enemy_flag = wesnoth.is_enemy(<span class="number">1</span>, <span class="number">3</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "get_sides"></a>
    <strong>get_sides (filter)</strong>
    </dt>
    <dd>
    Returns a table array containing tables for these sides matching the passed StandardSideFilter.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">tab</span></span>
         StandardSideFilter
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">{Side,...}</span></span>
        Array containing the matching sides.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- set gold to 0 for all sides with a leader
</span>sides = wesnoth.get_sides
    has_unit:
        can_recruit: <span class="keyword">true</span>
<span class="keyword">for</span> side <span class="keyword">in</span> *sides
    side.gold = <span class="number">0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "match_side"></a>
    <strong>match_side (side, filter)</strong>
    </dt>
    <dd>
    Matches a side against a given StandardSideFilter.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">side</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">tab</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesnoth.message(<span class="global">tostring</span>(wesnoth.match_side(<span class="number">1</span>, { has_unit: { <span class="global">type</span>: <span class="string">"Troll"</span> } } )))</pre>
    </ul>

</dd>
    <dt>
    <a name = "match_side-todo2"></a>
    <strong>match_side-todo2</strong>
    </dt>
    <dd>
     if (!side<em>string</em>.empty()) {</p>
<pre><code> if (!check_side_number(t,side_string_)) {
     return false;
 }
</code></pre>
<p> }







</dd>
    <dt>
    <a name = "get_starting_location"></a>
    <strong>get_starting_location ()</strong>
    </dt>
    <dd>
    Returns the starting location of the given side.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">loc = wesnoth.get_starting_location(<span class="number">1</span>)
 wesnoth.message <span class="string">"side 1 starts at (#{loc[1]}, #{loc[2]})"</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "get_village_owner"></a>
    <strong>get_village_owner (x, y)</strong>
    </dt>
    <dd>
    Stub text


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">number</span></span>
        the side that owns the village at the given location.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">owned_by_side_1 = wesnoth.get_village_owner(<span class="number">12</span>, <span class="number">15</span>) == <span class="number">1</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "set_side_id"></a>
    <strong>set_side_id (side)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">side</span>
            <span class="types"><span class="type">number</span></span>
         Changes the visual identification of a side.
 Pass an empty string if you only want to change one of these two attributes.
 (Version 1.13.7 and later only)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "place_shroud"></a>
    <strong>place_shroud ()</strong>
    </dt>
    <dd>
    Shrouds the specified hexes.
 (Version 1.13.7 and later only)
 You can pass a shroud_data string (which will be merged with existing shroud), a list of specific locations (where each location is a two-element list of x and y coordinates), or the special string "all" to shroud all hexes.







</dd>
    <dt>
    <a name = "remove_shroud"></a>
    <strong>remove_shroud ()</strong>
    </dt>
    <dd>
    (Version 1.13.7 and later only)
 Unshrouds the specified hexes.  Hexes are specified as with place<em>shroud, except that a shroud</em>data string will not work.







</dd>
    <dt>
    <a name = "is_fogged"></a>
    <strong>is_fogged ()</strong>
    </dt>
    <dd>
    (Version 1.13.7 and later only)
 Tests if the given location is under fog from the point of view of the given side.







</dd>
    <dt>
    <a name = "is_shrouded"></a>
    <strong>is_shrouded ()</strong>
    </dt>
    <dd>
    (Version 1.13.7 and later only)







</dd>
</dl>
    <h2 class="section-header "><a name="api_sound_Functions"></a>api.sound Functions</h2>

    <dl class="function">
    <dt>
    <a name = "set_music"></a>
    <strong>set_music (music_entry)</strong>
    </dt>
    <dd>
    Sets the given table as an entry into the music list. </p>

<p> See MusicListWML for the recognized attributes.</p>

<p> Passing no argument forces the engine to take into account all the recent changes to the music list.
 (Note: this is done automatically when sequences of WML commands end,
 so it is useful only for long events.)</p>

<p> This function is now deprecated. Use the wesnoth.music_list table instead


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">music_entry</span>
            <span class="types"><span class="type">MusicListWML</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesnoth.set_music { name: <span class="string">"traveling_minstrels.ogg"</span> }</pre>
    </ul>

</dd>
    <dt>
    <a name = "music_list"></a>
    <strong>music_list</strong>
    </dt>
    <dd>
    This is a table giving access to the current music playlist. </p>

<p> It can be accessed as a normal array,
 including the Lua length operator.<br/>
 If you assign a music config to an entry, the track is replaced.<br/>
 It is not a normal array however and cannot be manipulated with the table library.


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">current</span> (read-write) The currently-playing track. This may sometimes be a track that's not on the playlist - "play once" tracks are not placed on the playlist.
        <ul>
        <li><span class="parameter">__cfg</span>
         (read-only) Returns a copy of the current track information.
        </li>
        </li></ul>
        <li><span class="parameter">previous</span> (read-write): The track played before the current one. This may sometimes be a track that's not on the playlist - "play once" tracks are not placed on the playlist.
        <ul>
        <li><span class="parameter">__cfg</span>
         (read-only) Returns a copy of the previous track information.
 NOTE: Wesnoth's playlist implementation effectively "plays" every song as it's added to the playlist, so when replacing one playlist with another, this will return information on the second-to-last track added to the new playlist, not the track you actually heard playing from the playlist that was replaced.
        </li>
        </li></ul>
        <li><span class="parameter">current_i</span>
         (read-write)
 The index of the currently-playing track on the playlist, or nil if the currently-playing track is not on the playlist.
        </li>
        <li><span class="parameter">volume</span>
         (read-write)
 The current music volume,
 as a percentage of the user's preferred volume set in preferences.
        </li>
        <li><span class="parameter">all</span>
            <span class="types"><span class="type">track</span></span>
         (read-only)
 Returns a copy of the music list as an array of WML tables.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "music_list.add"></a>
    <strong>music_list.add (track_name[, immediate[, ms_before[, ms_after]]])</strong>
    </dt>
    <dd>
    Appends a track to the playlist.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">track_name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
        <li><span class="parameter">immediate</span>
            <span class="types"><span class="type">bool</span></span>
         If true is passed, also start playing the new track.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">ms_before</span>
            <span class="types"><span class="type">int</span></span>



         (<em>optional</em>)
        </li>
        <li><span class="parameter">ms_after</span>
            <span class="types"><span class="type">int</span></span>



         (<em>optional</em>)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "music_list.remove"></a>
    <strong>music_list.remove (...)</strong>
    </dt>
    <dd>
    Removes one or more tracks by their index. </p>

<p> You can pass as many indices as you wish.<br/>
 If one of the removed tracks is currently playing, it continues to play.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
            <span class="types"><span class="type">{int,...}</span></span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "music_list.clear"></a>
    <strong>music_list.clear ()</strong>
    </dt>
    <dd>
    Clears the playlist. </p>

<p> The currently-playing track continues to play.







</dd>
    <dt>
    <a name = "music_list.next"></a>
    <strong>music_list.next ()</strong>
    </dt>
    <dd>
    Stop playing the current track and move on to the next one. </p>

<p> This honours the shuffle settings.







</dd>
    <dt>
    <a name = "music_list.play"></a>
    <strong>music_list.play (track_name)</strong>
    </dt>
    <dd>
    Start playing a track without appending it to the playlist.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">track_name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         the file path to the track to playlist
        </li>
    </ul>





</dd>
    <dt>
    <a name = "play_sound"></a>
    <strong>play_sound (sound[, repeat_count])</strong>
    </dt>
    <dd>
    Plays the given sound file once,<br/>
 optionally repeating it one or more more times if an integer value
 is provided as a second argument
 (note that the sound is repeated the number of times specified in the second argument, i.e.  a second argument of 4 will cause the sound to be played once and then repeated four more times for a total of 5 plays. See the example below).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sound</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         path to the soundfile to play
        </li>
        <li><span class="parameter">repeat_count</span>
            <span class="types"><span class="type">int</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesnoth.play_sound<span class="string">"ambient/birds1.ogg"</span>
wesnoth.play_sound(<span class="string">"magic-holy-miss-3.ogg"</span>, <span class="number">4</span>) <span class="comment">-- played 1 + 4 = 5 times</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "sound_volume"></a>
    <strong>sound_volume (new_volume)</strong>
    </dt>
    <dd>
    Sets the current sound volume.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">new_volume</span>
            <span class="types"><span class="type">int</span></span>
         percentage of the user's preferred volume set in preferences.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Returns the previous sound volume in the same format.
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="api_time_Functions"></a>api.time Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.get_time_of_day"></a>
    <strong>wesmere.get_time_of_day ([for_turn=turn_number[, Second]])</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">for_turn</span>
            <span class="types"><span class="type">number</span></span>
         First parameter (optional) is the turn number for which to return the information, if unspecified: the current turn (turn_number).
         (<em>default</em> turn_number)
        </li>
        <li><span class="parameter">Second</span>
            <span class="types"><span class="type">{number,number,bool=false}</span></span>
         argument is an optional table. If present, first and second fields must be valid on-map coordinates and all current time_areas in the scenario are taken into account (if a time area happens to contain the passed hex). If the table isn't present, the scenario main schedule is returned. The table has an optional third parameter (boolean). If true (default: false), time of day modifying units and terrain (such as Mages of Light or lava) are taken into account (if the passed hex happens to be affected). The units' placement being considered is always the current one.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">time_of_day</span></span>
        The function returns a time of day table.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.get_time_of_day(<span class="number">2</span>, { <span class="number">37</span>, <span class="number">3</span>, <span class="keyword">true</span> })
get_time_of_day = (for_turn=wesmere.current.turn_number, [ {x, y, [consider_illuminates]} ]) -&gt;</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.add_time_area"></a>
    <strong>wesmere.add_time_area (cfg, string)</strong>
    </dt>
    <dd>
    Creates a new time area.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cfg</span> This takes a WSL table containing the same information normally used by the 'time_area' table.
        <ul>
        <li><span class="parameter">filter_location</span>
            <span class="types"><span class="type">tab</span></span>
         StandardLocationFilter: the locations to affect. note: only for [event][time<em>area]s - at scenario toplevel [time</em>area] does not support StandardLocationFilter, only location ranges
        </li>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">tab</span></span>
         the new schedule. type: "TimeWSL"
        </li>
        <li><span class="parameter">remove</span>
            <span class="types"><span class="type">bool</span></span>
         Indicates whether the specified time<em>area should be removed. Requires an identifier. If no identifier is used, however, all time</em>areas are removed.
        </li>
        <li><span class="parameter">current_time</span>
            <span class="types"><span class="type">number</span></span>
         The time slot number (starting with one) active at the creation of the area.
        </li>
        </li></ul>
        <li><span class="parameter">string</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        ,..} cfg.id  an unique identifier assigned to a time<em>area. Optional, unless you want to remove the time</em>area later. Can be a comma-separated list when removing time_areas, see below.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.remove_time_area"></a>
    <strong>wesmere.remove_time_area (id)</strong>
    </dt>
    <dd>
    Removes a time area.  This requires the time area to have been assigned an id at creation time.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         of the area to remove
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> id <span class="keyword">in</span> *({<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>})
    wesmere.remove_time_area(id)</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="api_units_Functions"></a>api.units Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.get_unit"></a>
    <strong>wesmere.get_unit (underlying_id)</strong>
    </dt>
    <dd>
    Returns the unit with the given underlying ID.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">underlying_id</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">Unit</span></span>
        with the underlying_id
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">unit = wesmere.get_unit(<span class="string">"kalenz"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_unit"></a>
    <strong>wesmere.get_unit (x, y)</strong>
    </dt>
    <dd>
    Returns the unit at the given location


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">Unit</span></span>
        at the location
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">args = ...
 unit = wesmere.get_unit(args.x1, args.y1)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_units"></a>
    <strong>wesmere.get_units (filter)</strong>
    </dt>
    <dd>
    Returns an array of all the units on the map matching the WSL filter passed as the first argument.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardUnitFilter</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">leaders_on_side_two = get_units { side: <span class="number">2</span>, can_recruit: <span class="keyword">true</span> }
 name_of_leader = leaders_on_side_two[<span class="number">1</span>].name</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.match_unit"></a>
    <strong>wesmere.match_unit (unit, filter[, other_unit])</strong>
    </dt>
    <dd>
    Returns true if the given unit matches the WSL filter passed as the second argument.  If other<em>unit is specified, it is used for the $other</em>unit auto-stored variable in the filter. Otherwise, this variable is not stored for the filter.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>



        </li>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardUnitFilter</span></span>



        </li>
        <li><span class="parameter">other_unit</span>
            <span class="types"><span class="type">Unit</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">assert</span>(unit.can_recruit == wesmere.match_unit(unit, { can_recruit: <span class="keyword">true</span> }))</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.erase_unit"></a>
    <strong>wesmere.erase_unit (unit)</strong>
    </dt>
    <dd>
    Erases a unit from the map.  After calling this on a unit, the unit is no longer valid.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.erase_unit"></a>
    <strong>wesmere.erase_unit (x, y)</strong>
    </dt>
    <dd>
    Erases a unit from the map.  After calling this on a unit, the unit is no longer valid.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>
        iff the unit was erased.
    </ol>


    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "wesmere.get_recall_units"></a>
    <strong>wesmere.get_recall_units (filter)</strong>
    </dt>
    <dd>
    Returns an array of all the units on the recall lists matching the WSL filter passed as the first argument.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter</span>
            <span class="types"><span class="type">StandardUnitFilter</span></span>



        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">{Unit,...}</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wesmere.put_recall_unit"></a>
    <strong>wesmere.put_recall_unit (unit[, side])</strong>
    </dt>
    <dd>
    Places a unit on a recall list.  This unit is described either by a WSL table or by a proxy unit. The side of the recall list is given by the second argument, or by the side of the unit if missing.
 When the argument is a proxy unit, no duplicate is created. In particular, if the unit was private or on the map, it no longer is. Note: passing a WSL table is just a shortcut for calling #wesmere.create_unit and then putting the resulting unit on a recall list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>



        </li>
        <li><span class="parameter">side</span>
            <span class="types"><span class="type">number</span></span>



         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- put the unit at location 17,42 on the recall list for side 2
</span> wesmere.put_recall_unit(wesmere.get_units({ x: <span class="number">17</span>, y: <span class="number">42</span> })[<span class="number">1</span>], <span class="number">2</span>)</pre></li>
        <li><pre class="example">wesmere.put_recall_unit = (unit, [side]) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.create_unit"></a>
    <strong>wesmere.create_unit (unit_info)</strong>
    </dt>
    <dd>
    Creates a private unit from a WSL table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit_info</span>
            <span class="types"><span class="type">unit_table</span></span>



        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">u = wesmere.create_unit { <span class="global">type</span>: <span class="string">"White Mage"</span>, gender: <span class="string">"female"</span> }</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.copy_unit"></a>
    <strong>wesmere.copy_unit ()</strong>
    </dt>
    <dd>
    Creates a private unit from another unit.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- extract a unit from the map
</span>u = wesmere.copy_unit(wesmere.get_units({ <span class="global">type</span>: <span class="string">"Thug"</span> })[<span class="number">1</span>])
wesmere.put_unit(u.x, u.y)
<span class="comment">-- u is still valid at this point</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.extract_unit"></a>
    <strong>wesmere.extract_unit ()</strong>
    </dt>
    <dd>
    Removes a unit from the map or from a recall list and makes it private.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- remove all the units from the recall list of side 1 and put them in a WSL container
</span>l = {}
<span class="keyword">for</span> u <span class="keyword">in</span> *wesmere.get_recall_units { side: <span class="number">1</span> }
    wesmere.extract_unit(u)
    <span class="global">table</span>.insert(l, u.__cfg)
helper.set_variable_array(<span class="string">"player_recall_list"</span>, l)
Note: <span class="keyword">if</span> the unit is on the map, it is just a shortcut <span class="keyword">for</span> calling #wesmere.copy_unit <span class="keyword">and</span> <span class="keyword">then</span> #wesmere.put_unit without a unit. It is, however, the only way <span class="keyword">for</span> removing a unit from a recall list without putting it on the map.</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.advance_unit"></a>
    <strong>wesmere.advance_unit (unit, animate, fire_events)</strong>
    </dt>
    <dd>
    Advances the unit (and shows the advance unit dialog if needed) if the unit has enough xp.  This function should be called after modifying the units experience directly. A similar function is called by wesmere internally after unit combat.
 This function only works for units on the map.
 This function can also trigger multiple advancements if the unit has enough xp.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>



        </li>
        <li><span class="parameter">animate</span>
            <span class="types"><span class="type">bool</span></span>
         specifies whether the advancement should be animated.
        </li>
        <li><span class="parameter">fire_events</span>
            <span class="types"><span class="type">bool</span></span>
         specifies whether advancement related events should be fired.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wesmere.add_modification"></a>
    <strong>wesmere.add_modification (It, type[, write_to_mods])</strong>
    </dt>
    <dd>
    Modifies a given unit.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">It</span>
            <span class="types"><span class="type">Unit</span></span>
         needs to be a proxy unit.
        </li>
        <li><span class="parameter">type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         of the modification (one of "trait", "object", or "advancement"). The option "advance" applies effects as if the unit would advance (e.g. AMLA effects).
 describing the effect, so mostly containing [effect] children. See EffectWSL for details about effects.
        </li>
        <li><span class="parameter">write_to_mods</span>
            <span class="types"><span class="type">bool</span></span>
         if false, causes it to not write the modification tag to the unit's [modifications] (as would be done with an [object] with no_write: true).
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">u = wesmere.get_units { canrecruit: <span class="keyword">true</span> }[<span class="number">1</span>]
 wesmere.add_modification(u, <span class="string">"object"</span>, { { <span class="string">"effect"</span>, { apply_to: <span class="string">"image_mod"</span>, replace: <span class="string">"RC(red&gt;blue)"</span> } } })</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_resistance"></a>
    <strong>wesmere.unit_resistance (whether[, loc])</strong>
    </dt>
    <dd>
    Returns the resistance of a unit against an attack type.  (Note: it is a WSL resistance. So the higher it is, the weaker the unit is.)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">whether</span>
            <span class="types"><span class="type">bool</span></span>
         the unit is the attacker.
        </li>
        <li><span class="parameter">loc</span>
            <span class="types"><span class="type">Location</span></span>
         coordinates of an optional map location (for the purpose of taking abilities into account).
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">fire_resistance = <span class="number">100</span> - wesmere.unit_resistance(u, <span class="string">"fire"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_defense"></a>
    <strong>wesmere.unit_defense ()</strong>
    </dt>
    <dd>
    Returns the defense of a unit on a particular terrain.  (Note: it is a WSL defense. So the higher it is, the weaker the unit is.)





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">flat_defense = <span class="number">100</span> - wesmere.unit_defense(u, <span class="string">"Gt"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_movement_cost"></a>
    <strong>wesmere.unit_movement_cost ()</strong>
    </dt>
    <dd>
    Returns the movement cost of a unit on a particular terrain.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">move_cost = wesmere.unit_movement_cost(u, <span class="string">"Gt"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_vision_cost"></a>
    <strong>wesmere.unit_vision_cost ()</strong>
    </dt>
    <dd>
    Returns the vision cost of a unit on a particular terrain.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">see_cost = wesmere.unit_vision_cost(u, <span class="string">"Gt"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_jamming_cost"></a>
    <strong>wesmere.unit_jamming_cost ()</strong>
    </dt>
    <dd>
    Returns the jamming cost of a unit on a particular terrain.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">jam_cost = wesmere.unit_jamming_cost(u, <span class="string">"Gt"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_ability"></a>
    <strong>wesmere.unit_ability ()</strong>
    </dt>
    <dd>
    Returns true if the unit is currently under effect by an ability with this given TAG NAME.  This means that the ability could be owned by the unit itself, or by an adjacent unit.





    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">has_teleport = (u) -&gt;
     <span class="keyword">return</span> wesmere.unit_ability(u, <span class="string">"teleport"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.unit_types"></a>
    <strong>wesmere.unit_types</strong>
    </dt>
    <dd>
    This is not a function but a table indexed by unit type ids.  Its elements are proxy tables with these fields:


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         name: translatable string (read only)
 max<em>moves, max</em>experience, max_hitpoints, level, cost: integers (read only)
 __cfg: WSL table (dump)
 The metatable of these proxy tables appears as "unit type".
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">lich_cost = wesmere.unit_types[<span class="string">"Ancient Lich"</span>].cost
 unit_types = <span class="global">require</span>(<span class="string">"server.wesnoth.wesmods"</span>).content.Units.unit_type</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.races"></a>
    <strong>wesmere.races</strong>
    </dt>
    <dd>
    This is not a function but a table indexed by race ids.  Its elements are proxy tables for all races the engine knows about. known fields of each element:


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         string
        </li>
        <li><span class="parameter">description</span>
            <span class="types"><span class="type">tstring</span></span>



        </li>
        <li><span class="parameter">name</span>
            <span class="types"><span class="type">tstring</span></span>



        </li>
        <li><span class="parameter">plural_name</span>
            <span class="types"><span class="type">tstring</span></span>
         (translatable strings)
        </li>
        <li><span class="parameter">num_traits</span>
            <span class="types"><span class="type">number</span></span>
         (integer)
        </li>
        <li><span class="parameter">ignore_global_traits</span>
            <span class="types"><span class="type">bool</span></span>
         (boolean)
        </li>
        <li><span class="parameter">undead_variation</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         (string)
 (all read only)
 __cfg: WSL table (dump)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.message(<span class="global">tostring</span>(wesmere.races[<span class="string">"lizard"</span>].name))
 races = {}</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_traits"></a>
    <strong>wesmere.get_traits ()</strong>
    </dt>
    <dd>
    Returns a table with named fields (trait id strings) holding the wsl tables defining the traits.  arguments: none. All global traits the engine knows about, race-specific traits are not included. Known fields and subtags of each element are the ones which were given in the wsl definition of the trait.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">tab</span></span>
        hmmmm
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.message(<span class="global">tostring</span>(wesmere.get_traits!.strong.male_name))</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.simulate_combat"></a>
    <strong>wesmere.simulate_combat ()</strong>
    </dt>
    <dd>
    Computes the hitpoint distribution and status chance after a combat between two units.  The first unit is the attacker; it does not have to be on the map, though its location should be meaningful. The second unit is the defender; it has to be on the map.
 Optional integers can be passed after each unit to select a particular weapon, otherwise the "best" one is selected. When giving the weapon, the parameter is the weapon number (integer, starting at 1) and not an element from the table returned by helper.child_range(att, "attack").






    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">display_stats = (n, t) -&gt;
    wesmere.message(<span class="global">string</span>.format(
        <span class="string">"Chance for the %s\n  to be slowed: %f,\n  to be poisoned: %f,\n  to die: %f.\nAverage HP: %f."</span>,
        n, t.slowed, t.poisoned, t.hp_chance[<span class="number">0</span>], t.average_hp))
att_stats, def_stats = wesmere.simulate_combat(att, att_weapon, def, def_weapon)
display_stats(<span class="string">"attacker"</span>, att_stats)
display_stats(<span class="string">"defender"</span>, def_stats)
Returns <span class="number">2</span> additional tables which contain information about the weapons <span class="keyword">and</span> the effect of single hits with these keys: num_blows, damage, chance_to_hit, poisons, slows, petrifies, plagues, plague_type, backstabs, rounds, firststrike, drains, drain_constant, drain_percent, attack_num, name. Name is the wsl name <span class="keyword">not</span> the description. If there is no weapon, <span class="keyword">then</span> name will be <span class="keyword">nil</span></pre></li>
        <li><pre class="example">att_stats, def_stats, att_weapon, def_weapon = wesmere.simulate_combat(attacker, att_weapon_number, defender)
wesmere.message(<span class="global">string</span>.format(
    <span class="string">"The attack %s should be countered with %s, which does %d damage, has %d%% chance to hit and forces %d attack rounds due to its berserk ability."</span>,
    att_weapon.name, def_weapon.name <span class="keyword">or</span> <span class="string">"no weapon"</span>, def_weapon.damage, def_weapon.chance_to_hit, def_weapon.rounds))</pre></li>
        <li><pre class="example">wesmere.simulate_combat = (attacker, [attacker_weapon_index], defender, [defender_weapon_index]) -&gt;</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.transform_unit"></a>
    <strong>wesmere.transform_unit (unit, to_type)</strong>
    </dt>
    <dd>
    Changes the type of a unit and adjust attributes accordingly.  Note that hit points are only changed if necessary to accommodate the new maximum hit points. Poison is automatically removed if the transformed unit is immune.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span></span>



        </li>
        <li><span class="parameter">to_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">ev = wesmere.current.event_context
u = wesmere.get_units{x=ev.x1, y=ev.y1}[<span class="number">1</span>]
wesmere.transform_unit(u, <span class="string">"Spearman"</span>)
<span class="comment">-- If a full heal is desired:
</span>u.hitpoints = u.max_hitpoints
u.status.poisoned = <span class="keyword">false</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.put_unit"></a>
    <strong>wesmere.put_unit (unit, x[, y])</strong>
    </dt>
    <dd>
    Places a unit on the map.  This unit is described either by a WSL table or by a Unit object. Coordinates can be passed as optional arguments, otherwise the table is expected to contain them.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">unit</span>
            <span class="types"><span class="type">Unit</span> or <span class="type">tab</span></span>



        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">number</span>, <span class="type">Location</span> or <span class="type">tab</span></span>



        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">number</span></span>



         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- create a unit with random traits, then erase it
</span>wesmere.put_unit({ <span class="global">type</span>: <span class="string">"Elvish Lady"</span> }, <span class="number">17</span>, <span class="number">42</span>)
wesmere.erase_unit(<span class="number">17</span>, <span class="number">42</span>)
When the argument is a proxy unit, no duplicate is created.
In particular, <span class="keyword">if</span> the unit was private <span class="keyword">or</span> on a recall list,
it no longer is; <span class="keyword">and</span> <span class="keyword">if</span> the unit was on the map,
it has been moved to the new location.
Note: passing a WML <span class="global">table</span> is just a shortcut <span class="keyword">for</span> calling #wesmere.create_unit <span class="keyword">and</span> <span class="keyword">then</span> putting the resulting unit on the map.</pre></li>
        <li><pre class="example"><span class="comment">-- move the leader back to the top-left corner
</span> wesmere.put_unit(wesmere.get_units({ can_recruit: <span class="keyword">true</span> })[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>)</pre></li>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="api_variables_Functions"></a>api.variables Functions</h2>

    <dl class="function">
    <dt>
    <a name = "wesmere.get_variable"></a>
    <strong>wesmere.get_variable ()</strong>
    </dt>
    <dd>
    Loads a WSL variable with the given qualified name (argument 1) and converts it into a Lua object.  Returns nil if the name does not point to anything, a scalar for a WSL attribute, and a table for a WSL object. The format of the table is described in LuaWSL#Encoding WSL objects into Lua tables.
 Argument 2, if true, prevents the recursive conversion when the name points to an object; a fresh empty table is returned in this case. This is mainly used for writing proxy objects, e.g. in #helper.set<em>wsl</em>var<em>metatable.
 Note that, if the variable name happens to designate a sequence of WSL objects, only the first one (index 0) is fetched. If all the WSL objects with this name should have been returned, use #helper.get</em>variable_array instead.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.fire(<span class="string">"store_unit"</span>, { variable:<span class="string">"my_unit"</span>, filter: { id:<span class="string">"hero"</span> } } )
heros_hp = wesmere.get_variable(<span class="string">"my_unit[0].hitpoints"</span>)
wesmere.message(<span class="global">string</span>.format(<span class="string">"The 'hero' unit has %d hitpoints."</span>, heros_hp))</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.set_variable"></a>
    <strong>wesmere.set_variable ()</strong>
    </dt>
    <dd>
    Stores a Lua value (argument 2) to a WSL variable (argument 1).
 Setting a WSL variable to nil erases it.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.set_variable(<span class="string">"my_unit.hitpoints"</span>, heros_hp + <span class="number">10</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "wesmere.get_all_vars"></a>
    <strong>wesmere.get_all_vars ()</strong>
    </dt>
    <dd>
    Returns all the WSL variables currently set in form of a WSL table.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">wesmere.get_all_vars = () -&gt;
<span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="global">pairs</span>( wesmere.get_all_vars! )
    <span class="keyword">if</span> <span class="global">type</span>( value ) == <span class="string">"table"</span>
        <span class="global">print</span>( key, value[<span class="number">1</span>], value[<span class="number">2</span>] )
    <span class="keyword">else</span>
        <span class="global">print</span>( key, value )</pre>
    </ul>

</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2018-06-20 13:13:00 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
